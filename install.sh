#!/usr/bin/env bash
# This script was generated by bashly 1.3.4 (https://bashly.dev)
# Modifying it manually is not recommended

# :wrapper.bash3_bouncer
if ((BASH_VERSINFO[0] < 4 || (BASH_VERSINFO[0] == 4 && BASH_VERSINFO[1] < 2))); then
  printf "bash version 4.2 or higher is required\n" >&2
  exit 1
fi

# :command.master_script
# :command.root_command
root_command() {
  # src/root_command.sh
  main() {
    local claude_dir="${args['--claude-dir']:-}"
    local hook_prefix="${args['--hook-prefix']:-}"

    init_claude_paths "$claude_dir" "$hook_prefix"

    print_banner
    print_overview

    step_deps
    step_shell
    step_hook
    step_permissions

    print_completion
  }

  # --- Steps ---

  step_deps() {
    step "Step 1/4: Dependencies"

    if check_all_deps; then
      success "All dependencies present"
      return 0
    fi

    warn "Some dependencies missing"
    read -p "Install missing dependencies? [Y/n] " -n 1 -r
    echo ""

    if [[ $REPLY =~ ^[Nn]$ ]]; then
      error "Cannot continue without dependencies"
      exit 1
    fi

    install_missing_deps || exit 1
  }

  step_shell() {
    step "Step 2/4: Shell configuration"

    local shell_path="${args['--shell']:-}"

    # Default to modern bash if not specified
    if [[ -z "$shell_path" ]]; then
      if ! shell_path=$(find_modern_bash); then
        error "Modern bash (4.4+) not found"
        info "Install with: brew install bash"
        info "Or specify a shell with: --shell /path/to/shell"
        exit 1
      fi
    fi

    local shell_name
    shell_name=$(basename "$shell_path")

    if [[ ! -x "$shell_path" ]]; then
      error "Shell not found or not executable: $shell_path"
      info "Use --shell to specify a valid shell path"
      exit 1
    fi

    local current_shell
    current_shell=$(get_setting '.env.SHELL')

    if [[ "$current_shell" == "$shell_path" ]]; then
      success "Shell already set to $shell_name"
      return 0
    fi

    info "Configuring Claude to use $shell_name ($shell_path)"
    set_setting '.env.SHELL' "\"$shell_path\""
    success "Shell configured"
  }

  step_hook() {
    step "Step 3/4: Installing allow-piped hook"

    local hook_file
    hook_file=$(get_hook_filepath)

    ensure_hooks_dir

    if [[ -f "$hook_file" ]]; then
      info "Hook already exists, updating..."
    fi

    generate_hook_script "$CLAUDE_DIR" > "$hook_file"
    chmod +x "$hook_file"
    success "Hook installed"

    configure_hook_in_settings
  }

  step_permissions() {
    step "Step 4/4: Adding safe permissions"

    local added=0

    for perm in "${DEFAULT_PERMISSIONS[@]}"; do
      if ! array_contains '.permissions.allow' "\"$perm\""; then
        array_add '.permissions.allow' "\"$perm\""
        ((added++)) || true
      fi
    done

    if [[ $added -eq 0 ]]; then
      success "All permissions already configured"
    else
      success "Added $added safe command permissions"
    fi
  }

  # --- Output ---

  print_banner() {
    echo ""
    echo "╔════════════════════════════════════════════╗"
    echo "║       Better Claude Code Installer         ║"
    echo "╚════════════════════════════════════════════╝"
    echo ""
  }

  print_overview() {
    info "This installer will:"
    echo "  1. Check/install dependencies (bash 4.4+, shfmt, jq)"
    echo "  2. Configure your preferred shell"
    echo "  3. Install the allow-piped hook"
    echo "  4. Add safe command permissions"
    echo ""
  }

  print_completion() {
    echo ""
    echo "╔════════════════════════════════════════════╗"
    echo "║            Installation Complete!          ║"
    echo "╚════════════════════════════════════════════╝"
    echo ""
    success "Better Claude Code is now configured!"
    echo ""
    info "Changes made to: $CLAUDE_SETTINGS"
    info "Hook installed to: $(get_hook_filepath)"
    echo ""
    info "Start a new Claude Code session to apply changes."
  }

  main

}

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
install.sh_usage() {
  printf "install.sh - Enhance Claude Code with better shell handling and command permissions\n\n"

  printf "%s\n" "Usage:"
  printf "  install.sh [OPTIONS]\n"
  printf "  install.sh --help | -h\n"
  printf "  install.sh --version | -v\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--claude-dir, -d DIR"
    printf "    Path to .claude directory (default: ~/.claude)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--hook-prefix, -p PREFIX"
    printf "    Prefix for hook filename (e.g., 'executable_' for chezmoi)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--shell, -s SHELL_PATH"
    printf "    Path to shell (default: modern bash)\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  local k

  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/colors.sh
# Terminal colors and output helpers

setup_colors() {
  if [[ -t 1 ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[0;33m'
    BLUE='\033[0;34m'
    BOLD='\033[1m'
    NC='\033[0m'
  else
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    BOLD=''
    NC=''
  fi
}

info() {
  printf "${BLUE}ℹ${NC} %s\n" "$*"
}

success() {
  printf "${GREEN}✓${NC} %s\n" "$*"
}

warn() {
  printf "${YELLOW}⚠${NC} %s\n" "$*" >&2
}

error() {
  printf "${RED}✗${NC} %s\n" "$*" >&2
}

step() {
  printf "\n${BOLD}→ %s${NC}\n" "$*"
}

# Initialize colors on source
setup_colors

# src/lib/deps.sh
# Dependency checking and installation helpers

# Minimum bash version required (for mapfile -d, nameref, etc.)
MIN_BASH_MAJOR=4
MIN_BASH_MINOR=4

# --- Public API ---

check_all_deps() {
  local all_ok=true

  check_homebrew_status || all_ok=false
  check_bash_status || all_ok=false
  check_jq_status || all_ok=false
  check_shfmt_status || all_ok=false

  $all_ok
}

install_missing_deps() {
  require_homebrew || return 1

  install_bash_if_needed || return 1
  install_if_missing jq || return 1
  install_if_missing shfmt || return 1

  success "All dependencies installed"
}

# --- Status checks ---

check_homebrew_status() {
  if has_homebrew; then
    success "Homebrew $(brew --version 2>/dev/null | head -1 | sed 's/Homebrew //')"
    return 0
  else
    error "Homebrew not found"
    return 1
  fi
}

check_bash_status() {
  if bash_version_ok; then
    success "bash $(get_bash_version) (>= $MIN_BASH_MAJOR.$MIN_BASH_MINOR required)"
    return 0
  fi

  local modern_bash
  if modern_bash=$(find_modern_bash); then
    success "bash $MIN_BASH_MAJOR.$MIN_BASH_MINOR+ found at $modern_bash"
    return 0
  fi

  error "bash $(get_bash_version) (need >= $MIN_BASH_MAJOR.$MIN_BASH_MINOR)"
  return 1
}

check_jq_status() {
  if command_exists jq; then
    success "jq $(jq --version 2>/dev/null | sed 's/jq-//')"
    return 0
  else
    error "jq not found"
    return 1
  fi
}

check_shfmt_status() {
  if command_exists shfmt; then
    success "shfmt $(shfmt --version 2>/dev/null)"
    return 0
  else
    error "shfmt not found"
    return 1
  fi
}

# --- Homebrew installation ---

require_homebrew() {
  if has_homebrew; then
    return 0
  fi

  prompt_homebrew_install
}

prompt_homebrew_install() {
  error "Homebrew is required but not installed"
  echo ""
  info "Homebrew is the package manager we'll use to install dependencies."
  info "Installation may take several minutes."
  echo ""

  read -p "Install Homebrew now? [Y/n] " -n 1 -r
  echo ""

  if [[ $REPLY =~ ^[Nn]$ ]]; then
    print_manual_homebrew_instructions
    return 1
  fi

  install_homebrew
}

install_homebrew() {
  info "Installing Homebrew (this may take a few minutes)..."
  echo ""

  /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

  if ! has_homebrew; then
    error "Homebrew installation failed"
    print_manual_homebrew_instructions
    return 1
  fi

  success "Homebrew installed successfully"
}

print_manual_homebrew_instructions() {
  echo ""
  echo "To install Homebrew manually, run:"
  # shellcheck disable=SC2016
  echo '  /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"'
  echo ""
  echo "Then run this installer again."
}

# --- Package installation ---

install_bash_if_needed() {
  if bash_version_ok || find_modern_bash &>/dev/null; then
    return 0
  fi
  brew_install bash
}

install_if_missing() {
  local package="$1"
  if command_exists "$package"; then
    return 0
  fi
  brew_install "$package"
}

brew_install() {
  local package="$1"
  info "Installing $package via Homebrew..."
  brew install "$package"
}

# --- Bash version helpers ---

bash_version_ok() {
  local bash_path="${1:-bash}"
  local version major minor

  # shellcheck disable=SC2016
  version=$("$bash_path" -c 'echo "${BASH_VERSINFO[0]}.${BASH_VERSINFO[1]}"' 2>/dev/null) || return 1
  major="${version%%.*}"
  minor="${version#*.}"

  ((major > MIN_BASH_MAJOR)) || ((major == MIN_BASH_MAJOR && minor >= MIN_BASH_MINOR))
}

get_bash_version() {
  local bash_path="${1:-bash}"
  # shellcheck disable=SC2016
  "$bash_path" -c 'echo "${BASH_VERSINFO[0]}.${BASH_VERSINFO[1]}"' 2>/dev/null
}

find_modern_bash() {
  local candidates=(
    "/opt/homebrew/bin/bash"
    "/usr/local/bin/bash"
    "/bin/bash"
  )

  for bash_path in "${candidates[@]}"; do
    if [[ -x "$bash_path" ]] && bash_version_ok "$bash_path"; then
      echo "$bash_path"
      return 0
    fi
  done

  return 1
}

# --- Low-level utilities ---

has_homebrew() {
  command_exists brew
}

command_exists() {
  command -v "$1" &>/dev/null
}

# src/lib/hook_script.sh
# This file contains a function that generates the allow-piped.sh hook script
# The script is generated with the correct CLAUDE_DIR path baked in

generate_hook_script() {
  local claude_dir="$1"

  cat << HOOK_EOF
#!/usr/bin/env bash
# allow-piped.sh - Hook to allow piped commands where ALL components are in allowed Bash permissions.
# Claude Code's prefix matching doesn't handle pipes - this hook fixes that.
#
# Dynamically reads allowed commands from:
#   1. $claude_dir/settings.json (global)
#   2. .claude/settings.json (project shared)
#   3. .claude/settings.local.json (project local)
#
# Dependencies: shfmt, jq
#
# Generated by better-claude-code installer

set -euo pipefail

# Configured claude directory
CLAUDE_DIR="$claude_dir"

# --- Main entry point ---

main() {
  parse_args "\$@"
  check_dependencies || exit 0

  local command
  command=\$(read_command_from_stdin) || exit 0
  [[ -z "\$command" ]] && exit 0

  check_command_allowed "\$command"
}

# --- High-level logic ---

check_command_allowed() {
  local command="\$1"
  local -a allowed_prefixes
  local -a extracted_commands

  mapfile -t allowed_prefixes < <(get_allowed_prefixes)
  debug "Loaded \${#allowed_prefixes[@]} allowed prefixes"

  if [[ \${#allowed_prefixes[@]} -eq 0 ]]; then
    debug "No Bash permissions found, exiting"
    exit 0
  fi

  mapfile -d '' extracted_commands < <(parse_shell_commands "\$command" 2>&1) || {
    debug "Command parsing failed, falling through"
    exit 0
  }

  debug "Extracted \${#extracted_commands[@]} commands:"
  for cmd in "\${extracted_commands[@]}"; do
    debug "  - \$cmd"
  done

  if [[ \${#extracted_commands[@]} -eq 0 ]] || [[ -z "\${extracted_commands[0]}" ]]; then
    debug "No commands found in input, allowing"
    output_allow
    exit 0
  fi

  if all_commands_allowed extracted_commands allowed_prefixes; then
    debug "Decision: ALLOW (all commands passed)"
    output_allow
  else
    debug "Decision: BLOCK (falling through to normal permission check)"
  fi

  exit 0
}

all_commands_allowed() {
  local -n commands_ref=\$1
  local -n prefixes_ref=\$2

  for full_command in "\${commands_ref[@]}"; do
    [[ -z "\$full_command" ]] && continue
    if ! is_command_allowed "\$full_command" prefixes_ref; then
      return 1
    fi
  done

  return 0
}

is_command_allowed() {
  local full_command="\$1"
  local -n prefixes=\$2

  for allowed in "\${prefixes[@]}"; do
    if [[ "\$full_command" == "\$allowed" ]] || \\
       [[ "\$full_command" == "\$allowed "* ]] || \\
       [[ "\$full_command" == "\$allowed/"* ]]; then
      debug "ALLOWED: '\$full_command' (matches '\$allowed')"
      return 0
    fi
  done

  debug "BLOCKED: '\$full_command' (no matching prefix)"
  return 1
}

# --- Input/Output ---

read_command_from_stdin() {
  local input command

  input=\$(cat)
  debug "Input JSON: \$input"

  command=\$(echo "\$input" | jq -r '.tool_input.command // empty')
  debug "Extracted command: \$command"

  echo "\$command"
}

output_allow() {
  echo '{"hookSpecificOutput":{"hookEventName":"PreToolUse","permissionDecision":"allow"}}'
}

# --- Settings and prefixes ---

get_allowed_prefixes() {
  local git_root
  git_root=\$(find_git_root)

  {
    extract_prefixes_from_file "\$CLAUDE_DIR/settings.json"

    if [[ -n "\$git_root" ]]; then
      extract_prefixes_from_file "\$git_root/.claude/settings.json"
      extract_prefixes_from_file "\$git_root/.claude/settings.local.json"
    else
      extract_prefixes_from_file ".claude/settings.json"
      extract_prefixes_from_file ".claude/settings.local.json"
    fi
  } | sort -u
}

extract_prefixes_from_file() {
  local file="\$1"

  if [[ ! -f "\$file" ]]; then
    debug "Settings file not found: \$file"
    return 0
  fi

  debug "Reading prefixes from: \$file"
  jq -r '.permissions.allow[]? // empty' "\$file" 2>/dev/null \\
    | grep -E '^Bash\(' \\
    | sed -E 's/^Bash\(([^:]+)(:\*)?.*/\1/'
}

find_git_root() {
  git rev-parse --show-toplevel 2>/dev/null
}

# --- Shell command parser ---

parse_shell_commands() {
  local cmd="\$1"
  local raw_commands

  debug "Input command: \$cmd"
  raw_commands=\$(extract_commands_raw "\$cmd") || return 1

  while IFS= read -r line; do
    [[ -z "\$line" ]] && continue

    local inner
    inner=\$(get_shell_c_inner "\$line")

    if [[ -n "\$inner" ]]; then
      debug "Found shell -c, recursing into: \$inner"
      parse_shell_commands "\$inner"
    else
      printf '%s\0' "\$line"
    fi
  done <<< "\$raw_commands"
}

extract_commands_raw() {
  local cmd="\$1"
  local ast

  debug "Parsing: \$cmd"
  cmd=\$(normalize_for_shfmt "\$cmd")
  debug "Normalized: \$cmd"

  if ! ast=\$(echo "\$cmd" | shfmt -ln bash -tojson 2>&1); then
    debug "Parse error: \$ast"
    return 1
  fi

  debug "AST parsed successfully"
  echo "\$ast" | jq -r "\$JQ_FILTER" 2>/dev/null
}

normalize_for_shfmt() {
  local cmd="\$1"
  echo "\$cmd" | perl -pe 's/\[\[\s*\\\\?!\s+(.+?)\s+=~\s*/! [[ \$1 =~ /g'
}

get_shell_c_inner() {
  local cmd="\$1"

  if [[ "\$cmd" =~ ^(bash|sh)[[:space:]]+-c[[:space:]]*[\'\"](.*)[\'\"]\$ ]]; then
    echo "\${BASH_REMATCH[2]}"
  elif [[ "\$cmd" =~ ^(bash|sh)[[:space:]]+-c[\'\"](.*)[\'\"]\$ ]]; then
    echo "\${BASH_REMATCH[2]}"
  fi
}

# --- Dependencies and setup ---

check_dependencies() {
  if ! command -v shfmt &>/dev/null; then
    debug "shfmt not found, falling through"
    return 1
  fi

  if ! command -v jq &>/dev/null; then
    debug "jq not found, falling through"
    return 1
  fi

  return 0
}

parse_args() {
  DEBUG=false
  [[ "\${1:-}" == "--debug" ]] && DEBUG=true
}

debug() {
  if \$DEBUG; then
    echo "[DEBUG] \$*" >&2
  fi
}

# --- jq filter for AST parsing ---

read -r -d '' JQ_FILTER << 'JQEOF' || true
def get_part_value:
  if (type == "object" | not) then ""
  elif .Type == "Lit" then .Value // ""
  elif .Type == "DblQuoted" then
    "\"" + ([.Parts[]? | get_part_value] | join("")) + "\""
  elif .Type == "SglQuoted" then
    "'" + (.Value // "") + "'"
  elif .Type == "ParamExp" then
    "\$" + (.Param.Value // "")
  elif .Type == "CmdSubst" then
    "\$(..)"
  else
    ""
  end;

def get_arg_value:
  [.Parts[]? | get_part_value] | join("");

def get_command_string:
  if .Type == "CallExpr" and .Args then
    [.Args[] | get_arg_value] | map(select(length > 0)) | join(" ")
  else
    empty
  end;

def extract_commands:
  if type == "object" then
    if .Type == "CallExpr" then
      get_command_string,
      (.Args[]?.Parts[]? | select(.Type == "CmdSubst") | .Stmts[]? | extract_commands)
    elif .Type == "BinaryCmd" then
      (.X | extract_commands),
      (.Y | extract_commands)
    elif .Type == "Subshell" or .Type == "Block" then
      (.Stmts[]? | extract_commands)
    elif .Type == "CmdSubst" then
      (.Stmts[]? | extract_commands)
    elif .Type == "IfClause" then
      (.Cond[]? | extract_commands),
      (.Then[]? | extract_commands),
      (.Else | extract_commands)
    elif .Type == "WhileClause" or .Type == "UntilClause" then
      (.Cond[]? | extract_commands),
      (.Do[]? | extract_commands)
    elif .Type == "ForClause" then
      (.Do[]? | extract_commands)
    elif .Type == "CaseClause" then
      (.Items[]?.Stmts[]? | extract_commands)
    elif .Cmd then
      (.Cmd | extract_commands)
    elif .Stmts then
      (.Stmts[] | extract_commands)
    else
      (.[] | extract_commands)
    end
  elif type == "array" then
    (.[] | extract_commands)
  else
    empty
  end;

extract_commands | select(length > 0)
JQEOF

# --- Run main ---

main "\$@"
HOOK_EOF
}

# src/lib/permissions.sh
# Default safe Bash permissions to add

# These are read-only or safe commands that Claude can run without user approval
# shellcheck disable=SC2034  # Used by permissions_command.sh and all_command.sh
DEFAULT_PERMISSIONS=(
  # Basic file operations (read-only)
  "Bash(cat:*)"
  "Bash(head:*)"
  "Bash(tail:*)"
  "Bash(less:*)"
  "Bash(more:*)"

  # File info
  "Bash(ls:*)"
  "Bash(file:*)"
  "Bash(stat:*)"
  "Bash(wc:*)"
  "Bash(du:*)"
  "Bash(df:*)"

  # Search and find
  "Bash(find:*)"
  "Bash(fd:*)"
  "Bash(grep:*)"
  "Bash(rg:*)"
  "Bash(awk:*)"
  "Bash(sed:*)"

  # Text processing
  "Bash(sort:*)"
  "Bash(uniq:*)"
  "Bash(cut:*)"
  "Bash(tr:*)"
  "Bash(column:*)"
  "Bash(fold:*)"
  "Bash(nl:*)"
  "Bash(paste:*)"
  "Bash(rev:*)"
  "Bash(tee:*)"

  # Path utilities
  "Bash(pwd:*)"
  "Bash(dirname:*)"
  "Bash(basename:*)"
  "Bash(realpath:*)"
  "Bash(readlink:*)"
  "Bash(which:*)"
  "Bash(type:*)"

  # System info
  "Bash(echo:*)"
  "Bash(date:*)"
  "Bash(cal:*)"
  "Bash(uname:*)"
  "Bash(hostname:*)"
  "Bash(whoami:*)"
  "Bash(id:*)"
  "Bash(env:*)"
  "Bash(printenv:*)"
  "Bash(locale:*)"
  "Bash(uptime:*)"

  # Git (read-only operations)
  "Bash(git status:*)"
  "Bash(git diff:*)"
  "Bash(git log:*)"
  "Bash(git show:*)"
  "Bash(git branch:*)"
  "Bash(git tag:*)"
  "Bash(git remote:*)"
  "Bash(git ls-files:*)"
  "Bash(git ls-tree:*)"
  "Bash(git blame:*)"
  "Bash(git rev-parse:*)"
  "Bash(git rev-list:*)"
  "Bash(git describe:*)"
  "Bash(git config --get:*)"
  "Bash(git config --list:*)"
  "Bash(git stash list:*)"
  "Bash(git fetch:*)"

  # JSON/data processing
  "Bash(jq:*)"

  # Checksums
  "Bash(md5:*)"
  "Bash(md5sum:*)"
  "Bash(shasum:*)"

  # Binary inspection
  "Bash(hexdump:*)"
  "Bash(xxd:*)"
  "Bash(od:*)"
  "Bash(strings:*)"

  # Process info (read-only)
  "Bash(ps:*)"
  "Bash(top -l 1:*)"

  # Other tools
  "Bash(tree:*)"
  "Bash(bat:*)"
  "Bash(eza:*)"
  "Bash(exa:*)"
  "Bash(fzf:*)"
  "Bash(seq:*)"
  "Bash(expr:*)"
  "Bash(test:*)"
  "Bash(xargs:*)"
  "Bash(man:*)"
  "Bash(tldr:*)"
  "Bash(shfmt:*)"
)

# src/lib/settings.sh
# Claude Code settings.json manipulation helpers

# These get initialized by init_claude_paths()
CLAUDE_DIR=""
CLAUDE_SETTINGS=""
CLAUDE_HOOKS_DIR=""
HOOK_FILE_PREFIX=""

# --- Initialization (must be called before using other functions) ---

init_claude_paths() {
  local custom_dir="${1:-}"
  local hook_prefix="${2:-}"

  CLAUDE_DIR="${custom_dir:-$HOME/.claude}"
  CLAUDE_SETTINGS="$CLAUDE_DIR/settings.json"
  CLAUDE_HOOKS_DIR="$CLAUDE_DIR/hooks"
  HOOK_FILE_PREFIX="${hook_prefix:-}"
}

get_hook_filename() {
  echo "${HOOK_FILE_PREFIX}allow-piped.sh"
}

get_hook_filepath() {
  echo "$CLAUDE_HOOKS_DIR/$(get_hook_filename)"
}

# --- Public API (step-down: high-level functions first) ---

set_setting() {
  local jq_path="$1"  # e.g., '.env.SHELL'
  local value="$2"    # JSON value, e.g., '"string"' or '123' or 'true'
  local current new

  current=$(get_settings)
  new=$(echo "$current" | jq "$jq_path = $value")
  write_settings "$new"
}

get_setting() {
  local jq_path="$1"  # e.g., '.env.SHELL'
  get_settings | jq -r "$jq_path // empty"
}

array_contains() {
  local jq_path="$1"  # e.g., '.permissions.allow'
  local value="$2"    # JSON value to check for, e.g., '"Bash(ls:*)"'

  get_settings | jq -e "$jq_path | index($value) != null" &>/dev/null
}

array_add() {
  local jq_path="$1"  # e.g., '.permissions.allow'
  local value="$2"    # JSON value to add, e.g., '"Bash(ls:*)"'
  local current new

  if array_contains "$jq_path" "$value"; then
    return 0
  fi

  current=$(get_settings)
  # First ensure the path exists, then add the value
  new=$(echo "$current" | jq "
    if $jq_path == null then
      $jq_path = []
    else
      .
    end
    | $jq_path += [$value]
    | $jq_path = ($jq_path | unique)
  ")
  write_settings "$new"
}

merge_setting() {
  local jq_path="$1"  # e.g., '.hooks'
  local obj="$2"      # JSON object to merge, e.g., '{"PreToolUse": [...]}'
  local current new

  current=$(get_settings)
  new=$(echo "$current" | jq "$jq_path = (($jq_path // {}) * $obj)")
  write_settings "$new"
}

# --- Directory management ---

ensure_claude_dir() {
  if [[ ! -d "$CLAUDE_DIR" ]]; then
    mkdir -p "$CLAUDE_DIR"
    info "Created $CLAUDE_DIR"
  fi
}

ensure_hooks_dir() {
  ensure_claude_dir
  if [[ ! -d "$CLAUDE_HOOKS_DIR" ]]; then
    mkdir -p "$CLAUDE_HOOKS_DIR"
    info "Created $CLAUDE_HOOKS_DIR"
  fi
}

# --- Low-level settings I/O ---

get_settings() {
  if [[ -f "$CLAUDE_SETTINGS" ]]; then
    cat "$CLAUDE_SETTINGS"
  else
    echo '{}'
  fi
}

write_settings() {
  local json="$1"
  ensure_claude_dir
  echo "$json" | jq '.' > "$CLAUDE_SETTINGS"
}

# --- Hook configuration ---

configure_hook_in_settings() {
  if hook_already_configured; then
    return 0
  fi
  add_hook_to_settings
}

add_hook_to_settings() {
  # Settings always reference the non-prefixed filename at $HOME/.claude
  # (prefix is only for dotfiles managers like chezmoi)
  # shellcheck disable=SC2016
  local new_hook='{"type": "command", "command": "$HOME/.claude/hooks/allow-piped.sh"}'

  local current new
  current=$(get_settings)

  # Check if a Bash matcher already exists in PreToolUse
  if echo "$current" | jq -e '.hooks.PreToolUse[]? | select(.matcher == "Bash")' &>/dev/null; then
    # Append our hook to the existing Bash matcher's hooks array
    new=$(echo "$current" | jq --argjson hook "$new_hook" '
      .hooks.PreToolUse = [
        .hooks.PreToolUse[] |
        if .matcher == "Bash" then
          .hooks += [$hook]
        else
          .
        end
      ]
    ')
  else
    # No Bash matcher exists, create a new entry
    local hook_entry
    hook_entry=$(jq -n --argjson hook "$new_hook" '{
      "matcher": "Bash",
      "hooks": [$hook]
    }')
    new=$(echo "$current" | jq --argjson entry "$hook_entry" '
      .hooks.PreToolUse = ((.hooks.PreToolUse // []) + [$entry])
    ')
  fi

  write_settings "$new"
}

hook_already_configured() {
  # Check if PreToolUse has a Bash matcher with allow-piped.sh command
  get_settings | jq -e '
    .hooks.PreToolUse[]?
    | select(.matcher == "Bash")
    | .hooks[]?
    | select(.command | endswith("allow-piped.sh"))
  ' &>/dev/null
}

# :command.command_functions

# :command.parse_requirements
parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        install.sh_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="root"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --claude-dir | -d)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--claude-dir']="$2"
          shift
          shift
        else
          printf "%s\n" "--claude-dir requires an argument: --claude-dir, -d DIR" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --hook-prefix | -p)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--hook-prefix']="$2"
          shift
          shift
        else
          printf "%s\n" "--hook-prefix requires an argument: --hook-prefix, -p PREFIX" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --shell | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--shell']="$2"
          shift
          shift
        else
          printf "%s\n" "--shell requires an argument: --shell, -s SHELL_PATH" >&2
          exit 1
        fi
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  declare -g version="0.1.0"
  set -e

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "root") root_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  # :command.start
  command_line_args=("$@")
  initialize
  run "${command_line_args[@]}"
fi

#!/bin/sh
# POSIX bootstrap: re-exec with modern bash if needed

# Colors (POSIX-compatible)
if [ -t 1 ]; then
  _RED="\033[0;31m"
  _GREEN="\033[0;32m"
  _YELLOW="\033[0;33m"
  _BLUE="\033[0;34m"
  _BOLD="\033[1m"
  _NC="\033[0m"
else
  _RED="" _GREEN="" _YELLOW="" _BLUE="" _BOLD="" _NC=""
fi

_info() { printf "${_BLUE}i${_NC} %s\\n" "$*"; }
_success() { printf "${_GREEN}+${_NC} %s\\n" "$*"; }
_error() { printf "${_RED}x${_NC} %s\\n" "$*" >&2; }
_cmd() { printf "${_BOLD}${_BLUE}%s${_NC}" "$1"; }

_prompt_yn() {
  # Usage: _prompt_yn "Question" && echo "yes" || echo "no"
  printf "${_YELLOW}?${_NC} %s [Y/n] " "$1"
  read -r _answer </dev/tty
  case "$_answer" in
    [nN]*) return 1 ;;
    *) return 0 ;;
  esac
}

_need_modern_bash() {
  [ -z "$BASH_VERSION" ] && return 0
  _major=$(echo "$BASH_VERSION" | cut -d. -f1)
  [ "$_major" -lt 4 ] && return 0
  return 1
}

_ensure_homebrew() {
  if command -v brew >/dev/null 2>&1; then
    return 0
  fi
  _info "Homebrew is not installed."
  if _prompt_yn "Install Homebrew?"; then
    _info "Installing Homebrew..."
    /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
    # Add Homebrew to PATH for this session
    if [ -x /opt/homebrew/bin/brew ]; then
      eval "$(/opt/homebrew/bin/brew shellenv)"
    elif [ -x /usr/local/bin/brew ]; then
      eval "$(/usr/local/bin/brew shellenv)"
    fi
    if command -v brew >/dev/null 2>&1; then
      _success "Homebrew installed successfully."
      return 0
    else
      _error "Failed to install Homebrew."
      return 1
    fi
  else
    _error "Homebrew is required. Please install it from https://brew.sh"
    return 1
  fi
}

_ensure_modern_bash() {
  for _b in /opt/homebrew/bin/bash /usr/local/bin/bash; do
    if [ -x "$_b" ]; then
      return 0
    fi
  done
  _info "bash 4.4+ is required but not found."
  if _prompt_yn "Install modern bash via Homebrew? ($(_cmd "brew install bash"))"; then
    _info "Installing bash..."
    brew install bash
    if [ -x /opt/homebrew/bin/bash ] || [ -x /usr/local/bin/bash ]; then
      _success "bash installed successfully."
      return 0
    else
      _error "Failed to install bash."
      return 1
    fi
  else
    _error "bash 4.4+ is required. Install with: $(_cmd "brew install bash")"
    return 1
  fi
}

if _need_modern_bash; then
  # Check for existing modern bash first
  for _b in /opt/homebrew/bin/bash /usr/local/bin/bash; do
    if [ -x "$_b" ]; then
      printf "Detected bash %s, using modern bash at %s...\\n" "$BASH_VERSION" "$_b"
      _tmp=$(mktemp)
      trap "rm -f \"$_tmp\"" EXIT
      curl -fsSL "https://raw.githubusercontent.com/AbdelrahmanHafez/better-claude-code/main/install.sh" -o "$_tmp"
      exec "$_b" "$_tmp" "$@"
    fi
  done

  # No modern bash found, try to install dependencies
  _ensure_homebrew || exit 1
  _ensure_modern_bash || exit 1

  # Try again after installation
  for _b in /opt/homebrew/bin/bash /usr/local/bin/bash; do
    if [ -x "$_b" ]; then
      _tmp=$(mktemp)
      trap "rm -f \"$_tmp\"" EXIT
      curl -fsSL "https://raw.githubusercontent.com/AbdelrahmanHafez/better-claude-code/main/install.sh" -o "$_tmp"
      exec "$_b" "$_tmp" "$@"
    fi
  done

  _error "Could not find modern bash after installation."
  exit 1
fi
# === End bootstrap ===


# This script was generated by bashly 1.3.4 (https://bashly.dev)
# Modifying it manually is not recommended

# :command.master_script
# :command.root_command
root_command() {
  # src/root_command.sh
  main() {
    local non_interactive="${args['--yes']:-}"

    init_claude_paths

    print_banner

    step_deps

    local mode="recommended"
    if [[ -z "$non_interactive" ]]; then
      mode=$(prompt_install_mode)
    fi

    if [[ "$mode" == "recommended" ]]; then
      run_recommended_install
    else
      run_custom_install
    fi

    print_completion
  }

  # --- Install modes ---

  run_recommended_install() {
    info "Installing with recommended settings..."
    echo ""

    step_shell
    step_hook
    step_permissions
  }

  run_custom_install() {
    info "Custom installation..."
    echo ""

    # Shell selection
    local shell_path="${args['--shell']:-}"
    if [[ -z "$shell_path" ]]; then
      shell_path=$(find_modern_bash)
    fi
    local shell_name
    shell_name=$(basename "$shell_path")

    if prompt_yes_no "Configure Claude Code to run commands in $shell_name?" "Y"; then
      step_shell
    else
      info "Skipping shell configuration"
    fi

    # Hook installation
    if prompt_yes_no "Auto-approve piped commands that match allowed patterns?" "Y"; then
      step_hook
    else
      info "Skipping hook installation"
    fi

    # Permissions
    if prompt_yes_no "Pre-approve common safe commands (ls, git status, grep, etc.)?" "Y"; then
      step_permissions
    else
      info "Skipping permissions"
    fi
  }

  # --- Steps ---

  step_deps() {
    step "Checking dependencies"

    if check_all_deps; then
      success "All dependencies present"
      return 0
    fi

    warn "Some dependencies missing"

    # Non-interactive mode: auto-install
    if [[ -n "${args['--yes']:-}" ]]; then
      install_missing_deps || exit 1
      return
    fi

    read -p "Install missing dependencies? [Y/n] " -n 1 -r
    echo ""

    if [[ $REPLY =~ ^[Nn]$ ]]; then
      error "Cannot continue without dependencies"
      exit 1
    fi

    install_missing_deps || exit 1
  }

  step_shell() {
    step "Configuring shell for Claude Code commands"

    local shell_path="${args['--shell']:-}"

    # Default to modern bash if not specified
    if [[ -z "$shell_path" ]]; then
      if ! shell_path=$(find_modern_bash); then
        error "Modern bash (4.4+) not found"
        info "Install with: brew install bash"
        info "Or specify a shell with: --shell /path/to/shell"
        exit 1
      fi
    fi

    local shell_name
    shell_name=$(basename "$shell_path")

    if [[ ! -x "$shell_path" ]]; then
      error "Shell not found or not executable: $shell_path"
      info "Use --shell to specify a valid shell path"
      exit 1
    fi

    info "Configuring Claude to use $shell_name ($shell_path)"

    # Set env.SHELL in settings.json (for when Claude fixes the bug)
    set_setting '.env.SHELL' "\"$shell_path\""

    # Add shell alias to shell config files (workaround until bug is fixed)
    configure_shell_alias "$shell_path"

    success "Claude Code will now run commands in $shell_name"
  }

  step_hook() {
    step "Installing hook to auto-approve allowed commands"

    local hook_file
    hook_file=$(get_hook_filepath)

    ensure_hooks_dir

    if [[ -f "$hook_file" ]]; then
      info "Hook already exists, updating..."
    fi

    get_hook_script_content > "$hook_file"
    chmod +x "$hook_file"
    success "Hook installed"

    configure_hook_in_settings
  }

  step_permissions() {
    step "Adding safe permissions"

    local added=0

    for perm in "${DEFAULT_PERMISSIONS[@]}"; do
      if ! array_contains '.permissions.allow' "\"$perm\""; then
        array_add '.permissions.allow' "\"$perm\""
        ((added++)) || true
      fi
    done

    if [[ $added -eq 0 ]]; then
      success "All permissions already configured"
    else
      success "Added $added safe command permissions"
    fi
  }

  # --- Output ---

  print_banner() {
    echo ""
    echo "╔════════════════════════════════════════════╗"
    echo "║       Better Claude Code Installer         ║"
    echo "╚════════════════════════════════════════════╝"
    echo ""
  }

  # --- Prompts ---

  prompt_install_mode() {
    # Print menu to /dev/tty so it's not captured by command substitution
    printf '\n' > /dev/tty
    printf "${BOLD}Choose installation mode:${NC}\n" > /dev/tty
    printf '\n' > /dev/tty
    printf "  ${GREEN}[1]${NC} ${BOLD}Recommended${NC} - Install everything with sensible defaults\n" > /dev/tty
    printf "      • Claude Code runs commands in modern bash (4.4+)\n" > /dev/tty
    printf "      • Auto-approve hook for compound commands\n" > /dev/tty
    printf "      • Safe read-only command permissions\n" > /dev/tty
    printf '\n' > /dev/tty
    printf "  ${BLUE}[2]${NC} ${BOLD}Custom${NC} - Choose what to install\n" > /dev/tty
    printf '\n' > /dev/tty

    local choice
    while true; do
      read -p "Enter choice [1/2]: " -n 1 -r choice
      printf '\n' > /dev/tty
      case "$choice" in
        1) echo "recommended"; return ;;
        2) echo "custom"; return ;;
        "") echo "recommended"; return ;;  # Default to recommended
        *) warn "Please enter 1 or 2" ;;
      esac
    done
  }

  prompt_yes_no() {
    local prompt="$1"
    local default="${2:-Y}"  # Y or N

    local hint
    if [[ "$default" == "Y" ]]; then
      hint="[Y/n]"
    else
      hint="[y/N]"
    fi

    local reply
    read -p "$prompt $hint " -n 1 -r reply
    echo ""

    if [[ -z "$reply" ]]; then
      reply="$default"
    fi

    [[ "$reply" =~ ^[Yy]$ ]]
  }

  print_completion() {
    echo ""
    echo "╔════════════════════════════════════════════╗"
    echo "║            Installation Complete!          ║"
    echo "╚════════════════════════════════════════════╝"
    echo ""
    success "Better Claude Code is now configured!"
    echo ""
    info "Settings file: $CLAUDE_SETTINGS"
    if [[ -f "$(get_hook_filepath)" ]]; then
      info "Hook file: $(get_hook_filepath)"
    fi
    echo ""
    # Prompt to apply chezmoi if any managed files were modified
    if has_chezmoi_modifications; then
      echo ""
      # Replace $HOME with ~ for display
      local chezmoi_targets="${CHEZMOI_MODIFIED_FILES[*]}"
      chezmoi_targets="${chezmoi_targets//$HOME/\~}"
      local chezmoi_cmd="chezmoi apply $chezmoi_targets"
      if prompt_yes_no "Run $(cmd "$chezmoi_cmd") now?" "Y"; then
        # shellcheck disable=SC2086
        chezmoi apply $chezmoi_targets
        success "Chezmoi applied"
      else
        warn "Remember to run $(cmd "$chezmoi_cmd") before using Claude Code"
      fi
    fi
    echo ""
    local source_cmd
    case "$(basename "$SHELL")" in
      fish) source_cmd="source ~/.config/fish/config.fish" ;;
      zsh)  source_cmd="source ~/.zshrc" ;;
      *)    source_cmd="source ~/.bashrc" ;;
    esac
    info "Open a new terminal or run $(cmd "$source_cmd"), then run $(cmd "claude") to start."
    echo ""
    info "Review $(cmd "$CLAUDE_SETTINGS") to remove any permissions you don't want auto-approved."
  }

  main

}

# :command.version_command
version_command() {
  echo "$version"
}

# :command.usage
install.sh_usage() {
  printf "install.sh - Enhance Claude Code with better shell handling and command permissions\n\n"

  printf "%s\n" "Usage:"
  printf "  install.sh [OPTIONS]\n"
  printf "  install.sh --help | -h\n"
  printf "  install.sh --version | -v\n"
  echo

  # :command.long_usage
  if [[ -n "$long_usage" ]]; then
    # :command.usage_options
    printf "%s\n" "Options:"

    # :command.usage_flags
    # :flag.usage
    printf "  %s\n" "--shell, -s SHELL_PATH"
    printf "    Path to shell (default: modern bash)\n"
    echo

    # :flag.usage
    printf "  %s\n" "--yes, -y"
    printf "    Non-interactive mode, accept all defaults\n"
    echo

    # :command.usage_fixed_flags
    printf "  %s\n" "--help, -h"
    printf "    Show this help\n"
    echo
    printf "  %s\n" "--version, -v"
    printf "    Show version number\n"
    echo

  fi
}

# :command.normalize_input
# :command.normalize_input_function
normalize_input() {
  local arg passthru flags
  passthru=false

  while [[ $# -gt 0 ]]; do
    arg="$1"
    if [[ $passthru == true ]]; then
      input+=("$arg")
    elif [[ $arg =~ ^(--[a-zA-Z0-9_\-]+)=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^(-[a-zA-Z0-9])=(.+)$ ]]; then
      input+=("${BASH_REMATCH[1]}")
      input+=("${BASH_REMATCH[2]}")
    elif [[ $arg =~ ^-([a-zA-Z0-9][a-zA-Z0-9]+)$ ]]; then
      flags="${BASH_REMATCH[1]}"
      for ((i = 0; i < ${#flags}; i++)); do
        input+=("-${flags:i:1}")
      done
    elif [[ "$arg" == "--" ]]; then
      passthru=true
      input+=("$arg")
    else
      input+=("$arg")
    fi

    shift
  done
}

# :command.inspect_args
inspect_args() {
  local k

  if ((${#args[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!args[@]}" | sort)
    echo args:
    for k in "${sorted_keys[@]}"; do
      echo "- \${args[$k]} = ${args[$k]}"
    done
  else
    echo args: none
  fi

  if ((${#deps[@]})); then
    readarray -t sorted_keys < <(printf '%s\n' "${!deps[@]}" | sort)
    echo
    echo deps:
    for k in "${sorted_keys[@]}"; do
      echo "- \${deps[$k]} = ${deps[$k]}"
    done
  fi

  if ((${#env_var_names[@]})); then
    readarray -t sorted_names < <(printf '%s\n' "${env_var_names[@]}" | sort)
    echo
    echo "environment variables:"
    for k in "${sorted_names[@]}"; do
      echo "- \$$k = ${!k:-}"
    done
  fi
}

# :command.user_lib
# src/lib/colors.sh
# Terminal colors and output helpers

setup_colors() {
  if [[ -t 1 ]]; then
    RED='\033[0;31m'
    GREEN='\033[0;32m'
    YELLOW='\033[0;33m'
    BLUE='\033[0;34m'
    BOLD='\033[1m'
    NC='\033[0m'
  else
    RED=''
    GREEN=''
    YELLOW=''
    BLUE=''
    BOLD=''
    NC=''
  fi
}

info() {
  printf "${BLUE}ℹ${NC} %s\n" "$*"
}

success() {
  printf "${GREEN}✓${NC} %s\n" "$*"
}

warn() {
  printf "${YELLOW}⚠${NC} %s\n" "$*" >&2
}

error() {
  printf "${RED}✗${NC} %s\n" "$*" >&2
}

step() {
  printf "\n${BOLD}→ %s${NC}\n" "$*"
}

# Format a command for display (cyan/bold)
cmd() {
  printf "${BOLD}${BLUE}%s${NC}" "$1"
}

# Initialize colors on source
setup_colors

# src/lib/deps.sh
# Dependency checking and installation helpers

# Minimum bash version required (for mapfile -d, nameref, etc.)
MIN_BASH_MAJOR=4
MIN_BASH_MINOR=4

# --- Public API ---

check_all_deps() {
  local all_ok=true

  check_homebrew_status || all_ok=false
  check_bash_status || all_ok=false
  check_jq_status || all_ok=false
  check_shfmt_status || all_ok=false

  $all_ok
}

install_missing_deps() {
  require_homebrew || return 1

  install_bash_if_needed || return 1
  install_if_missing jq || return 1
  install_if_missing shfmt || return 1

  success "All dependencies installed"
}

# --- Status checks ---

check_homebrew_status() {
  if has_homebrew; then
    success "Homebrew $(brew --version 2>/dev/null | head -1 | sed 's/Homebrew //')"
    return 0
  else
    error "Homebrew not found"
    return 1
  fi
}

check_bash_status() {
  if bash_version_ok; then
    success "bash $(get_bash_version) (>= $MIN_BASH_MAJOR.$MIN_BASH_MINOR required)"
    return 0
  fi

  local modern_bash
  if modern_bash=$(find_modern_bash); then
    success "bash $MIN_BASH_MAJOR.$MIN_BASH_MINOR+ found at $modern_bash"
    return 0
  fi

  error "bash $(get_bash_version) (need >= $MIN_BASH_MAJOR.$MIN_BASH_MINOR)"
  return 1
}

check_jq_status() {
  if command_exists jq; then
    success "jq $(jq --version 2>/dev/null | sed 's/jq-//')"
    return 0
  else
    error "jq not found"
    return 1
  fi
}

check_shfmt_status() {
  if command_exists shfmt; then
    success "shfmt $(shfmt --version 2>/dev/null)"
    return 0
  else
    error "shfmt not found"
    return 1
  fi
}

# --- Homebrew installation ---

require_homebrew() {
  if has_homebrew; then
    return 0
  fi

  prompt_homebrew_install
}

prompt_homebrew_install() {
  error "Homebrew is required but not installed"
  echo ""
  info "Homebrew is the package manager we'll use to install dependencies."
  info "Installation may take several minutes."
  echo ""

  read -p "Install Homebrew now? [Y/n] " -n 1 -r
  echo ""

  if [[ $REPLY =~ ^[Nn]$ ]]; then
    print_manual_homebrew_instructions
    return 1
  fi

  install_homebrew
}

install_homebrew() {
  info "Installing Homebrew (this may take a few minutes)..."
  echo ""

  /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"

  if ! has_homebrew; then
    error "Homebrew installation failed"
    print_manual_homebrew_instructions
    return 1
  fi

  success "Homebrew installed successfully"
}

print_manual_homebrew_instructions() {
  echo ""
  echo "To install Homebrew manually, run:"
  # shellcheck disable=SC2016
  echo '  /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"'
  echo ""
  echo "Then run this installer again."
}

# --- Package installation ---

install_bash_if_needed() {
  if bash_version_ok || find_modern_bash &>/dev/null; then
    return 0
  fi
  brew_install bash
}

install_if_missing() {
  local package="$1"
  if command_exists "$package"; then
    return 0
  fi
  brew_install "$package"
}

brew_install() {
  local package="$1"
  info "Installing $package via Homebrew..."
  brew install "$package"
}

# --- Bash version helpers ---

bash_version_ok() {
  local bash_path="${1:-bash}"
  local version major minor

  # shellcheck disable=SC2016
  version=$("$bash_path" -c 'echo "${BASH_VERSINFO[0]}.${BASH_VERSINFO[1]}"' 2>/dev/null) || return 1
  major="${version%%.*}"
  minor="${version#*.}"

  ((major > MIN_BASH_MAJOR)) || ((major == MIN_BASH_MAJOR && minor >= MIN_BASH_MINOR))
}

get_bash_version() {
  local bash_path="${1:-bash}"
  # shellcheck disable=SC2016
  "$bash_path" -c 'echo "${BASH_VERSINFO[0]}.${BASH_VERSINFO[1]}"' 2>/dev/null
}

find_modern_bash() {
  local candidates=(
    "/opt/homebrew/bin/bash"
    "/usr/local/bin/bash"
    "/bin/bash"
  )

  for bash_path in "${candidates[@]}"; do
    if [[ -x "$bash_path" ]] && bash_version_ok "$bash_path"; then
      echo "$bash_path"
      return 0
    fi
  done

  return 1
}

# --- Low-level utilities ---

has_homebrew() {
  command_exists brew
}

command_exists() {
  command -v "$1" &>/dev/null
}

# src/lib/hook_content.sh
# Auto-generated from assets/auto-approve-allowed-commands.sh - DO NOT EDIT DIRECTLY
# Edit assets/auto-approve-allowed-commands.sh instead, then run: ./build.sh

get_hook_script_content() {
  cat << 'HOOK_SCRIPT_EOF'
#!/usr/bin/env bash
# Hook to allow piped commands where ALL components are in the allowed Bash permissions.
# Claude Code's prefix matching doesn't handle pipes - this hook fixes that.
# Dynamically reads allowed commands from:
#   1. ~/.claude/settings.json (global)
#   2. .claude/settings.json (project shared)
#   3. .claude/settings.local.json (project local)
#
# Dependencies: shfmt, jq
#
# Usage: echo '{"tool_input":{"command":"ls | grep foo"}}' | auto-approve-allowed-commands.sh [OPTIONS]
#
# Options:
#   --debug                 Enable debug output to stderr
#   --permissions JSON      Use custom permissions instead of reading from settings files
#                           JSON format: '["Bash(ls:*)", "Bash(grep:*)"]'
#
# Examples:
#   # Normal usage (reads permissions from settings files)
#   echo '{"tool_input":{"command":"ls | grep foo"}}' | auto-approve-allowed-commands.sh
#
#   # Testing with custom permissions
#   echo '{"tool_input":{"command":"ls | grep foo"}}' | auto-approve-allowed-commands.sh --permissions '["Bash(ls:*)", "Bash(grep:*)"]'

set -euo pipefail

# Debug mode
DEBUG=false
NUL_DELIM=false
# Custom permissions for testing (JSON array like: '["Bash(ls:*)", "Bash(cat:*)"]')
CUSTOM_PERMISSIONS=""

debug() {
  if $DEBUG; then
    echo "[DEBUG] $*" >&2
  fi
}

# Extract prefixes from a JSON array of permissions (for testing)
# Input: '["Bash(ls:*)", "Bash(grep:*)", "Bash(git log:*)"]'
# Output: ls\ngrep\ngit log
extract_prefixes_from_json() {
  local json="$1"
  echo "$json" | jq -r '.[]? // empty' 2>/dev/null \
    | grep -E '^Bash\(' \
    | sed -E 's/^Bash\(//; s/(:\*)?\)$//'
}

# Extract allowed Bash command prefixes from a settings file
# Matches patterns like Bash(ls:*), Bash(git log:*), etc.
extract_prefixes_from_file() {
  local file="$1"
  if [[ ! -f "$file" ]]; then
    debug "Settings file not found: $file"
    return 0
  fi
  debug "Reading prefixes from: $file"
  jq -r '.permissions.allow[]? // empty' "$file" 2>/dev/null \
    | grep -E '^Bash\(' \
    | sed -E 's/^Bash\(//; s/(:\*)?\)$//'
}

# Find git root directory (project root)
find_git_root() {
  git rev-parse --show-toplevel 2>/dev/null
}

# Get all allowed prefixes from all settings files (or custom permissions if set for testing)
get_allowed_prefixes() {
  # If custom permissions are set (for testing), use those instead
  if [[ -n "$CUSTOM_PERMISSIONS" ]]; then
    debug "Using custom permissions: $CUSTOM_PERMISSIONS"
    extract_prefixes_from_json "$CUSTOM_PERMISSIONS"
    return
  fi

  local git_root
  git_root=$(find_git_root)

  {
    # Global settings
    extract_prefixes_from_file "$HOME/.claude/settings.json"

    # Project settings (from git root if available, otherwise cwd)
    if [[ -n "$git_root" ]]; then
      extract_prefixes_from_file "$git_root/.claude/settings.json"
      extract_prefixes_from_file "$git_root/.claude/settings.local.json"
    else
      extract_prefixes_from_file ".claude/settings.json"
      extract_prefixes_from_file ".claude/settings.local.json"
    fi
  } | sort -u
}

# Check if a command matches any allowed prefix
# full_command: the extracted command with all args (e.g., "git log --oneline")
# allowed_prefixes: array of allowed prefixes from settings (e.g., "git log", "grep")
is_command_allowed() {
  local full_command="$1"
  local -n prefixes_ref=$2  # nameref to array

  for allowed in "${prefixes_ref[@]}"; do
    # Check if command starts with the allowed prefix
    # "git log --oneline" matches "git log" and "git"
    # "grep -E pattern" matches "grep"
    # "python3 .claude/skills/foo/bar.py" matches "python3 .claude/skills:*"
    if [[ "$full_command" == "$allowed" ]] || [[ "$full_command" == "$allowed "* ]] || [[ "$full_command" == "$allowed/"* ]]; then
      debug "ALLOWED: '$full_command' (matches '$allowed')"
      return 0
    fi
  done

  debug "BLOCKED: '$full_command' (no matching prefix)"
  return 1
}

main() {
  # Parse arguments
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --debug)
        DEBUG=true
        shift
        ;;
      --permissions)
        CUSTOM_PERMISSIONS="$2"
        shift 2
        ;;
      *)
        shift
        ;;
    esac
  done

  # Check for required dependencies
  if ! command -v jq &>/dev/null; then
    debug "jq not found, falling through to normal permission check"
    exit 0
  fi

  # Read the command from stdin (hook input is JSON)
  input=$(cat)
  debug "Input JSON: $input"
  command=$(echo "$input" | jq -r '.tool_input.command // empty')
  debug "Extracted command:"
  debug "$command"

  # Exit early if no command
  if [[ -z "$command" ]]; then
    debug "No command found, exiting"
    exit 0
  fi

  # Load allowed prefixes into array
  mapfile -t allowed_prefixes < <(get_allowed_prefixes)
  debug "Loaded ${#allowed_prefixes[@]} allowed prefixes"

  # If no prefixes (no Bash permissions), exit without allowing
  if [[ ${#allowed_prefixes[@]} -eq 0 ]]; then
    debug "No Bash permissions found, exiting"
    exit 0
  fi

  # Extract commands using built-in parser (NUL-delimited for multi-line command support)
  NUL_DELIM=true
  mapfile -d '' extracted_commands < <(extract_commands_from_string "$command") || {
    debug "Command parsing failed"
    debug "Falling through to normal permission check"
    exit 0
  }
  debug "Extracted ${#extracted_commands[@]} commands:"
  for cmd in "${extracted_commands[@]}"; do
    debug "  - $cmd"
  done

  # Check if no commands were found (empty input or only comments)
  if [[ ${#extracted_commands[@]} -eq 0 ]] || [[ -z "${extracted_commands[0]}" ]]; then
    debug "No commands found in input, allowing"
    echo '{"hookSpecificOutput":{"hookEventName":"PreToolUse","permissionDecision":"allow"}}'
    exit 0
  fi

  # Check each command against allowed prefixes
  all_allowed=true
  for full_command in "${extracted_commands[@]}"; do
    [[ -z "$full_command" ]] && continue

    if ! is_command_allowed "$full_command" allowed_prefixes; then
      all_allowed=false
      break
    fi
  done

  if $all_allowed; then
    debug "Decision: ALLOW (all commands passed)"
    echo '{"hookSpecificOutput":{"hookEventName":"PreToolUse","permissionDecision":"allow"}}'
  else
    debug "Decision: BLOCK (falling through to normal permission check)"
  fi

  exit 0
}
# shell-commands - Extract individual commands from a shell command string
#
# DESCRIPTION
#   Parses a shell command string and outputs each individual command on a
#   separate line. Uses shfmt for proper shell parsing, handling all shell
#   syntax correctly.
#
# USAGE
#   shell-commands [OPTIONS] [COMMAND]
#   echo "COMMAND" | shell-commands [OPTIONS]
#
# OPTIONS
#   -h, --help     Show this help message
#   -d, --debug    Enable debug output to stderr
#   -0, --null     Use NUL character as delimiter instead of newline
#                  (for programmatic use with: mapfile -d '' array < <(...))
#
# SUPPORTED SYNTAX
#   - Pipes:              cmd1 | cmd2 | cmd3
#   - And/Or:             cmd1 && cmd2 || cmd3
#   - Semicolons:         cmd1; cmd2; cmd3
#   - Newlines:           cmd1
#                         cmd2
#   - Line continuations: cmd1 \
#                           --flag | cmd2
#   - Pipe continuations: cmd1 |
#                           cmd2
#   - Comments:           cmd1  # inline comment
#                         # standalone comment
#   - Quoted strings:     grep -E "pattern|with|pipes" file
#   - Single quotes:      grep -E 'pattern' file
#   - Subshells:          (cmd1; cmd2) | cmd3
#   - Command substitution: echo $(cmd1 | cmd2)
#   - Variable expansion: echo $HOME
#   - bash -c / sh -c:    bash -c 'cmd1 | cmd2' (recursively expanded)
#
# QUOTE PRESERVATION
#   Quoted strings are preserved in output exactly as they appear in input.
#   Double quotes: grep -E "(int|long)" -> grep -E "(int|long)"
#   Single quotes: grep 'pattern' -> grep 'pattern'
#
# MALFORMED INPUT
#   If a newline breaks a command in the wrong place (e.g., between a flag
#   and its argument), shfmt will parse it as separate statements. This is
#   correct behavior - the input is invalid shell syntax.
#
#   Example of malformed input:
#     grep -E
#        "pattern"    <- This becomes a separate "command"
#
#   Correct alternatives:
#     grep -E "pattern"              <- single line
#     grep -E \
#        "pattern"                   <- backslash continuation
#     grep -E |
#        other_cmd                   <- pipe at end continues
#
# OUTPUT
#   Each command is printed on a separate line with all its arguments.
#   Only the command and arguments are printed, not the operators.
#
# EXAMPLES
#   $ shell-commands 'ls -la | grep foo | head -5'
#   ls -la
#   grep foo
#   head -5
#
#   $ shell-commands 'git status && git add . && git commit -m "msg"'
#   git status
#   git add .
#   git commit -m "msg"
#
#   $ echo 'grep -E "(int|long)" file.cs | head' | shell-commands
#   grep -E "(int|long)" file.cs
#   head
#
# DEPENDENCIES
#   - shfmt (brew install shfmt)
#   - jq (brew install jq)
#
# EXIT CODES
#   0 - Success
#   1 - Parse error or invalid input
#   2 - Missing dependencies
#

show_help() {
  sed -n '2,/^$/p' "$0" | sed 's/^# \?//'
}

# Check dependencies
check_deps() {
  local missing=()
  command -v shfmt &>/dev/null || missing+=(shfmt)
  command -v jq &>/dev/null || missing+=(jq)

  if [[ ${#missing[@]} -gt 0 ]]; then
    echo "Error: Missing dependencies: ${missing[*]}" >&2
    echo "Install with: brew install ${missing[*]}" >&2
    exit 2
  fi
}

# jq filter to extract commands from shfmt AST
# This walks the entire AST and extracts all CallExpr nodes
# Preserves quoting style from the original command
read -r -d '' JQ_FILTER << 'JQEOF' || true
# Recursively get string value from any word part, preserving quotes
def get_part_value:
  if (type == "object" | not) then ""
  elif .Type == "Lit" then .Value // ""
  elif .Type == "DblQuoted" then
    "\"" + ([.Parts[]? | get_part_value] | join("")) + "\""
  elif .Type == "SglQuoted" then
    "'" + (.Value // "") + "'"
  elif .Type == "ParamExp" then
    "$" + (.Param.Value // "")
  elif .Type == "CmdSubst" then
    # Represent command substitution as placeholder - nested commands extracted separately
    "$(..)"
  else
    ""
  end;

# Recursively find all CmdSubst and ProcSubst nodes in word parts (handles DblQuoted nesting)
def find_cmd_substs:
  if type == "object" then
    if .Type == "CmdSubst" or .Type == "ProcSubst" then .
    elif .Type == "DblQuoted" then .Parts[]? | find_cmd_substs
    elif .Parts then .Parts[]? | find_cmd_substs
    else empty
    end
  elif type == "array" then .[] | find_cmd_substs
  else empty
  end;

# Get full argument value (may have multiple parts concatenated)
def get_arg_value:
  [.Parts[]? | get_part_value] | join("");

# Get full command string from CallExpr
def get_command_string:
  if .Type == "CallExpr" and .Args then
    [.Args[] | get_arg_value] | map(select(length > 0)) | join(" ")
  else
    empty
  end;

# Recursively find and extract all commands
def extract_commands:
  if type == "object" then
    if .Type == "CallExpr" then
      get_command_string,
      # Also extract nested command substitutions (including inside DblQuoted)
      (.Args[]? | find_cmd_substs | .Stmts[]? | extract_commands)
    elif .Type == "BinaryCmd" then
      (.X | extract_commands),
      (.Y | extract_commands)
    elif .Type == "Subshell" or .Type == "Block" then
      (.Stmts[]? | extract_commands)
    elif .Type == "CmdSubst" then
      (.Stmts[]? | extract_commands)
    elif .Type == "IfClause" then
      (.Cond[]? | extract_commands),
      (.Then[]? | extract_commands),
      (.Else | extract_commands)
    elif .Type == "WhileClause" or .Type == "UntilClause" then
      (.Cond[]? | extract_commands),
      (.Do[]? | extract_commands)
    elif .Type == "ForClause" then
      # Extract from loop iterator (e.g., `for i in $(cmd)`)
      (.Loop.Items[]? | find_cmd_substs | .Stmts[]? | extract_commands),
      (.Do[]? | extract_commands)
    elif .Type == "CaseClause" then
      (.Items[]?.Stmts[]? | extract_commands)
    elif .Cmd then
      (.Cmd | extract_commands)
    elif .Stmts then
      (.Stmts[] | extract_commands)
    else
      (.[] | extract_commands)
    end
  elif type == "array" then
    (.[] | extract_commands)
  else
    empty
  end;

extract_commands | select(length > 0)
JQEOF

# Normalize shfmt-incompatible patterns
# shfmt can't parse [[ ! X =~ Y ]] but can parse ! [[ X =~ Y ]]
normalize_for_shfmt() {
  local cmd="$1"
  # Transform [[ ! ... =~ ... ]] to ! [[ ... =~ ... ]]
  # Also handle \! (escaped bang from some shells)
  # Use perl for more reliable regex with non-greedy matching
  echo "$cmd" | perl -pe 's/\[\[\s*\\?!\s+(.+?)\s+=~\s*/! [[ $1 =~ /g'
}

# Extract raw commands from AST (internal, always newline-separated)
extract_commands_raw() {
  local cmd="$1"
  local ast

  debug "Parsing: $cmd"

  # Normalize patterns that shfmt can't handle
  cmd=$(normalize_for_shfmt "$cmd")
  debug "Normalized: $cmd"

  # Parse with shfmt (use bash dialect for bash-specific syntax like =~)
  if ! ast=$(echo "$cmd" | shfmt -ln bash -tojson 2>&1); then
    debug "Parse error: $ast"
    echo "Parse error: $ast" >&2
    return 1
  fi

  debug "AST parsed successfully"

  # Extract commands using jq (always newline-separated internally)
  echo "$ast" | jq -r "$JQ_FILTER" 2>/dev/null
}

# Check if a command is "bash -c" or "sh -c" and extract the inner command
# Returns the inner command string if it matches, empty otherwise
# Handles:
#   - bash -c 'cmd' / sh -c 'cmd'
#   - /bin/bash -c 'cmd' / /usr/bin/bash -c 'cmd' (absolute paths)
#   - env bash -c 'cmd' / env sh -c 'cmd' (env prefix)
#   - env /bin/bash -c 'cmd' (env with absolute path)
get_shell_c_inner() {
  local cmd="$1"

  # Pattern components:
  # - Optional 'env ' prefix
  # - Optional path prefix (e.g., /bin/, /usr/bin/)
  # - bash or sh
  # - -c flag with optional space
  # - quoted string
  # Note: Using separate checks for clarity and to avoid complex regex escaping

  # Strip optional 'env ' prefix first
  local stripped="$cmd"
  if [[ "$cmd" =~ ^env[[:space:]]+ ]]; then
    stripped="${cmd#env }"
    stripped="${stripped# }"  # Remove any extra spaces
  fi

  # Strip optional path prefix (e.g., /bin/, /usr/bin/)
  if [[ "$stripped" =~ ^/[^[:space:]]*/(.+)$ ]]; then
    stripped="${BASH_REMATCH[1]}"
  fi

  # Now match: bash -c '...' or sh -c '...'
  if [[ "$stripped" =~ ^(bash|sh)[[:space:]]+-c[[:space:]]*[\'\"](.*)[\'\"]$ ]]; then
    echo "${BASH_REMATCH[2]}"
  elif [[ "$stripped" =~ ^(bash|sh)[[:space:]]+-c[\'\"](.*)[\'\"]$ ]]; then
    echo "${BASH_REMATCH[2]}"
  fi
}

# Main extraction function - handles bash -c recursively
extract_commands_from_string() {
  local cmd="$1"
  local raw_commands

  debug "Input command: $cmd"

  # Get raw commands
  raw_commands=$(extract_commands_raw "$cmd") || return 1

  # Process each command, recursively expanding bash -c / sh -c
  while IFS= read -r line; do
    [[ -z "$line" ]] && continue

    local inner
    inner=$(get_shell_c_inner "$line")

    if [[ -n "$inner" ]]; then
      debug "Found shell -c, recursing into: $inner"
      # Recursively extract commands from the inner script
      extract_commands_from_string "$inner"
    else
      # Output the command with appropriate delimiter
      if $NUL_DELIM; then
        printf '%s\0' "$line"
      else
        echo "$line"
      fi
    fi
  done <<< "$raw_commands"
}

parse_commands() {
  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h|--help)
        show_help
        exit 0
        ;;
      -d|--debug)
        DEBUG=true
        shift
        ;;
      -0|--null)
        NUL_DELIM=true
        shift
        ;;
      --)
        shift
        break
        ;;
      -*)
        echo "Unknown option: $1" >&2
        exit 1
        ;;
      *)
        break
        ;;
    esac
  done

  check_deps

  # Get command from argument or stdin
  if [[ $# -gt 0 ]]; then
    command_str="$*"
  else
    command_str=$(cat)
  fi

  if [[ -z "$command_str" ]]; then
    echo "Error: No command provided" >&2
    exit 1
  fi

  extract_commands_from_string "$command_str"
}

case "${1:-}" in
	parse_commands)
		shift
		parse_commands "$@"
		;;
	*)
		main "$@"
		;;
esac
HOOK_SCRIPT_EOF
}

# src/lib/permissions.sh
# Default safe Bash permissions to add
# These are read-only or safe commands that Claude can run without user approval

# shellcheck disable=SC2034  # Used by permissions_command.sh and all_command.sh
DEFAULT_PERMISSIONS=(
  "Bash(./gradlew --version:*)"
  "Bash(./gradlew dependencies:*)"
  "Bash(./gradlew tasks:*)"
  "Bash(R --version:*)"
  "Bash(Rscript --version:*)"
  "Bash(actionlint --version:*)"
  "Bash(age --version:*)"
  "Bash(ansible --version:*)"
  "Bash(ansible-galaxy list:*)"
  "Bash(ansible-inventory --list:*)"
  "Bash(ansible-playbook --version:*)"
  "Bash(ant -diagnostics:*)"
  "Bash(ant -version:*)"
  "Bash(apropos:*)"
  "Bash(ar --version:*)"
  "Bash(arp:*)"
  "Bash(asciidoctor --version:*)"
  "Bash(asdf --version:*)"
  "Bash(asdf current:*)"
  "Bash(asdf list:*)"
  "Bash(asdf plugin list:*)"
  "Bash(atuin --version:*)"
  "Bash(atuin history stats:*)"
  "Bash(aws --version:*)"
  "Bash(aws cloudformation describe-stacks:*)"
  "Bash(aws cloudformation list-stacks:*)"
  "Bash(aws configure get:*)"
  "Bash(aws configure list:*)"
  "Bash(aws dynamodb list-tables:*)"
  "Bash(aws ec2 describe-instances:*)"
  "Bash(aws ec2 describe-security-groups:*)"
  "Bash(aws ec2 describe-subnets:*)"
  "Bash(aws ec2 describe-vpcs:*)"
  "Bash(aws ecs describe-services:*)"
  "Bash(aws ecs list-clusters:*)"
  "Bash(aws ecs list-services:*)"
  "Bash(aws eks describe-cluster:*)"
  "Bash(aws eks list-clusters:*)"
  "Bash(aws help:*)"
  "Bash(aws iam get-user:*)"
  "Bash(aws iam list-roles:*)"
  "Bash(aws iam list-users:*)"
  "Bash(aws lambda get-function:*)"
  "Bash(aws lambda list-functions:*)"
  "Bash(aws logs describe-log-groups:*)"
  "Bash(aws logs describe-log-streams:*)"
  "Bash(aws rds describe-db-instances:*)"
  "Bash(aws s3 ls:*)"
  "Bash(aws s3api list-buckets:*)"
  "Bash(aws ssm describe-parameters:*)"
  "Bash(aws ssm get-parameter:*)"
  "Bash(aws sts get-caller-identity:*)"
  "Bash(aws sts get-session-token:*)"
  "Bash(az --version:*)"
  "Bash(az account list:*)"
  "Bash(az account show:*)"
  "Bash(az acr list:*)"
  "Bash(az ad user list:*)"
  "Bash(az aks list:*)"
  "Bash(az functionapp list:*)"
  "Bash(az group list:*)"
  "Bash(az group show:*)"
  "Bash(az help:*)"
  "Bash(az network vnet list:*)"
  "Bash(az sql server list:*)"
  "Bash(az storage account list:*)"
  "Bash(az version:*)"
  "Bash(az vm list:*)"
  "Bash(az vm show:*)"
  "Bash(az webapp list:*)"
  "Bash(bandit --version:*)"
  "Bash(basename:*)"
  "Bash(bat --version:*)"
  "Bash(bat:*)"
  "Bash(biome --version:*)"
  "Bash(black --version:*)"
  "Bash(bottom --version:*)"
  "Bash(brew --caskroom:*)"
  "Bash(brew --cellar:*)"
  "Bash(brew --prefix:*)"
  "Bash(brew --version:*)"
  "Bash(brew cat:*)"
  "Bash(brew config:*)"
  "Bash(brew deps:*)"
  "Bash(brew desc:*)"
  "Bash(brew doctor:*)"
  "Bash(brew home:*)"
  "Bash(brew info:*)"
  "Bash(brew leaves:*)"
  "Bash(brew list:*)"
  "Bash(brew log:*)"
  "Bash(brew outdated:*)"
  "Bash(brew search:*)"
  "Bash(brew tap-info:*)"
  "Bash(brew uses:*)"
  "Bash(broot --version:*)"
  "Bash(btm --version:*)"
  "Bash(buf --version:*)"
  "Bash(bun --version:*)"
  "Bash(bun -v:*)"
  "Bash(bun pm bin:*)"
  "Bash(bun pm cache:*)"
  "Bash(bun pm ls:*)"
  "Bash(bundle --version:*)"
  "Bash(bundle check:*)"
  "Bash(bundle config list:*)"
  "Bash(bundle info:*)"
  "Bash(bundle list:*)"
  "Bash(bundle outdated:*)"
  "Bash(bundle show:*)"
  "Bash(bundle version:*)"
  "Bash(bundler --version:*)"
  "Bash(bw --version:*)"
  "Bash(bw status:*)"
  "Bash(cabal --version:*)"
  "Bash(cal:*)"
  "Bash(cargo --version:*)"
  "Bash(cargo -V:*)"
  "Bash(cargo check:*)"
  "Bash(cargo doc:*)"
  "Bash(cargo help:*)"
  "Bash(cargo info:*)"
  "Bash(cargo locate-project:*)"
  "Bash(cargo metadata:*)"
  "Bash(cargo pkgid:*)"
  "Bash(cargo read-manifest:*)"
  "Bash(cargo search:*)"
  "Bash(cargo tree:*)"
  "Bash(cargo verify-project:*)"
  "Bash(cassandra -v:*)"
  "Bash(cat:*)"
  "Bash(cd:*)"
  "Bash(chezmoi apply ~/.claude:*)"
  "Bash(chezmoi apply ~/bin:*)"
  "Bash(chezmoi cat-config:*)"
  "Bash(chezmoi data:*)"
  "Bash(chezmoi diff:*)"
  "Bash(chezmoi managed:*)"
  "Bash(chezmoi source-path:*)"
  "Bash(chezmoi status:*)"
  "Bash(clang --version:*)"
  "Bash(clang++ --version:*)"
  "Bash(clippy-driver --version:*)"
  "Bash(cloc --version:*)"
  "Bash(cloc:*)"
  "Bash(clojure --version:*)"
  "Bash(cmake --version:*)"
  "Bash(code --list-extensions:*)"
  "Bash(code --version:*)"
  "Bash(codesign -d:*)"
  "Bash(codesign -v:*)"
  "Bash(column:*)"
  "Bash(commitlint --version:*)"
  "Bash(composer --version:*)"
  "Bash(composer info:*)"
  "Bash(composer show:*)"
  "Bash(conda --version:*)"
  "Bash(conda config --show:*)"
  "Bash(conda env list:*)"
  "Bash(conda info:*)"
  "Bash(conda list:*)"
  "Bash(conda search:*)"
  "Bash(cqlsh --version:*)"
  "Bash(cspell --version:*)"
  "Bash(csrutil status:*)"
  "Bash(curl --head:*)"
  "Bash(curl --version:*)"
  "Bash(curl -I:*)"
  "Bash(curl -v:*)"
  "Bash(cursor --version:*)"
  "Bash(cut:*)"
  "Bash(date:*)"
  "Bash(delta --version:*)"
  "Bash(delta:*)"
  "Bash(deno --version:*)"
  "Bash(deno check:*)"
  "Bash(deno doc:*)"
  "Bash(deno info:*)"
  "Bash(df:*)"
  "Bash(diff:*)"
  "Bash(dig:*)"
  "Bash(direnv --version:*)"
  "Bash(direnv status:*)"
  "Bash(dirname:*)"
  "Bash(diskutil info:*)"
  "Bash(diskutil list:*)"
  "Bash(ditto --version:*)"
  "Bash(docker buildx inspect:*)"
  "Bash(docker buildx ls:*)"
  "Bash(docker compose config:*)"
  "Bash(docker compose images:*)"
  "Bash(docker compose logs:*)"
  "Bash(docker compose ps:*)"
  "Bash(docker compose top:*)"
  "Bash(docker compose version:*)"
  "Bash(docker config inspect:*)"
  "Bash(docker config ls:*)"
  "Bash(docker container inspect:*)"
  "Bash(docker container ls:*)"
  "Bash(docker context inspect:*)"
  "Bash(docker context ls:*)"
  "Bash(docker diff:*)"
  "Bash(docker events:*)"
  "Bash(docker history:*)"
  "Bash(docker image inspect:*)"
  "Bash(docker image ls:*)"
  "Bash(docker images:*)"
  "Bash(docker info:*)"
  "Bash(docker inspect:*)"
  "Bash(docker logs:*)"
  "Bash(docker manifest inspect:*)"
  "Bash(docker network inspect:*)"
  "Bash(docker network ls:*)"
  "Bash(docker node inspect:*)"
  "Bash(docker node ls:*)"
  "Bash(docker plugin ls:*)"
  "Bash(docker port:*)"
  "Bash(docker ps:*)"
  "Bash(docker search:*)"
  "Bash(docker secret ls:*)"
  "Bash(docker service inspect:*)"
  "Bash(docker service logs:*)"
  "Bash(docker service ls:*)"
  "Bash(docker stack ls:*)"
  "Bash(docker stack ps:*)"
  "Bash(docker stack services:*)"
  "Bash(docker stats:*)"
  "Bash(docker system df:*)"
  "Bash(docker system info:*)"
  "Bash(docker top:*)"
  "Bash(docker --version:*)"
  "Bash(docker version:*)"
  "Bash(docker volume inspect:*)"
  "Bash(docker volume ls:*)"
  "Bash(docker-compose config:*)"
  "Bash(docker-compose images:*)"
  "Bash(docker-compose logs:*)"
  "Bash(docker-compose ps:*)"
  "Bash(docker-compose top:*)"
  "Bash(docker-compose version:*)"
  "Bash(dotnet --info:*)"
  "Bash(dotnet --list-runtimes:*)"
  "Bash(dotnet --list-sdks:*)"
  "Bash(dotnet --version:*)"
  "Bash(du:*)"
  "Bash(duf --version:*)"
  "Bash(duf:*)"
  "Bash(dune --version:*)"
  "Bash(dust --version:*)"
  "Bash(dust:*)"
  "Bash(echo:*)"
  "Bash(elasticdump --version:*)"
  "Bash(elixir --version:*)"
  "Bash(elixirc --version:*)"
  "Bash(emacs --version:*)"
  "Bash(entr --version:*)"
  "Bash(erl -version:*)"
  "Bash(eslint --version:*)"
  "Bash(exa --version:*)"
  "Bash(exa:*)"
  "Bash(expr:*)"
  "Bash(eza --version:*)"
  "Bash(eza:*)"
  "Bash(fd:*)"
  "Bash(file:*)"
  "Bash(flake8 --version:*)"
  "Bash(fnm --version:*)"
  "Bash(fnm current:*)"
  "Bash(fnm list:*)"
  "Bash(fold:*)"
  "Bash(free:*)"
  "Bash(fswatch --version:*)"
  "Bash(fzf --version:*)"
  "Bash(g++ --version:*)"
  "Bash(gcc --version:*)"
  "Bash(gcloud --version:*)"
  "Bash(gcloud auth list:*)"
  "Bash(gcloud compute instances describe:*)"
  "Bash(gcloud compute instances list:*)"
  "Bash(gcloud compute regions list:*)"
  "Bash(gcloud compute zones list:*)"
  "Bash(gcloud config get:*)"
  "Bash(gcloud config list:*)"
  "Bash(gcloud container clusters describe:*)"
  "Bash(gcloud container clusters list:*)"
  "Bash(gcloud functions list:*)"
  "Bash(gcloud help:*)"
  "Bash(gcloud iam service-accounts list:*)"
  "Bash(gcloud projects describe:*)"
  "Bash(gcloud projects list:*)"
  "Bash(gcloud run services list:*)"
  "Bash(gcloud sql instances list:*)"
  "Bash(gcloud storage ls:*)"
  "Bash(gcloud version:*)"
  "Bash(gdb --version:*)"
  "Bash(gem --version:*)"
  "Bash(gem -v:*)"
  "Bash(gem contents:*)"
  "Bash(gem dependency:*)"
  "Bash(gem environment:*)"
  "Bash(gem help:*)"
  "Bash(gem info:*)"
  "Bash(gem list:*)"
  "Bash(gem query:*)"
  "Bash(gem search:*)"
  "Bash(gem spec:*)"
  "Bash(gem specification:*)"
  "Bash(gem which:*)"
  "Bash(getconf:*)"
  "Bash(gh --version:*)"
  "Bash(gh api --method GET:*)"
  "Bash(gh api -X GET:*)"
  "Bash(gh api /:*)"
  "Bash(gh api repos:*)"
  "Bash(gh api search/code:*)"
  "Bash(gh auth status:*)"
  "Bash(gh config get:*)"
  "Bash(gh config list:*)"
  "Bash(gh extension list:*)"
  "Bash(gh gist list:*)"
  "Bash(gh gist view:*)"
  "Bash(gh help:*)"
  "Bash(gh issue list:*)"
  "Bash(gh issue status:*)"
  "Bash(gh issue view:*)"
  "Bash(gh label list:*)"
  "Bash(gh pr checks:*)"
  "Bash(gh pr diff:*)"
  "Bash(gh pr list:*)"
  "Bash(gh pr status:*)"
  "Bash(gh pr view:*)"
  "Bash(gh release list:*)"
  "Bash(gh release view:*)"
  "Bash(gh repo clone:*)"
  "Bash(gh repo list:*)"
  "Bash(gh repo view:*)"
  "Bash(gh run list:*)"
  "Bash(gh run view:*)"
  "Bash(gh search:*)"
  "Bash(gh secret list:*)"
  "Bash(gh status:*)"
  "Bash(gh variable list:*)"
  "Bash(gh workflow list:*)"
  "Bash(gh workflow view:*)"
  "Bash(ghc --version:*)"
  "Bash(ghci --version:*)"
  "Bash(git blame:*)"
  "Bash(git branch:*)"
  "Bash(git cat-file:*)"
  "Bash(git cherry:*)"
  "Bash(git config --get:*)"
  "Bash(git config --list:*)"
  "Bash(git count-objects:*)"
  "Bash(git describe:*)"
  "Bash(git diff:*)"
  "Bash(git fetch:*)"
  "Bash(git for-each-ref:*)"
  "Bash(git fsck:*)"
  "Bash(git log:*)"
  "Bash(git ls-files:*)"
  "Bash(git ls-remote:*)"
  "Bash(git ls-tree:*)"
  "Bash(git merge-base:*)"
  "Bash(git name-rev:*)"
  "Bash(git notes show:*)"
  "Bash(git reflog:*)"
  "Bash(git remote:*)"
  "Bash(git rev-list:*)"
  "Bash(git rev-parse:*)"
  "Bash(git shortlog:*)"
  "Bash(git show-branch:*)"
  "Bash(git show-ref:*)"
  "Bash(git show:*)"
  "Bash(git stash list:*)"
  "Bash(git stash show:*)"
  "Bash(git status:*)"
  "Bash(git symbolic-ref:*)"
  "Bash(git tag:*)"
  "Bash(git verify-commit:*)"
  "Bash(git verify-tag:*)"
  "Bash(git whatchanged:*)"
  "Bash(glow --version:*)"
  "Bash(glow:*)"
  "Bash(go --version:*)"
  "Bash(go doc:*)"
  "Bash(go env:*)"
  "Bash(go help:*)"
  "Bash(go list:*)"
  "Bash(go mod download -json:*)"
  "Bash(go mod graph:*)"
  "Bash(go mod verify:*)"
  "Bash(go mod why:*)"
  "Bash(go tool:*)"
  "Bash(go version:*)"
  "Bash(gofmt -d:*)"
  "Bash(goimports -d:*)"
  "Bash(gpg --list-keys:*)"
  "Bash(gpg --list-secret-keys:*)"
  "Bash(gpg --version:*)"
  "Bash(gradle --version:*)"
  "Bash(gradle -v:*)"
  "Bash(gradle dependencies:*)"
  "Bash(gradle help:*)"
  "Bash(gradle projects:*)"
  "Bash(gradle properties:*)"
  "Bash(gradle tasks:*)"
  "Bash(gradlew --version:*)"
  "Bash(grep:*)"
  "Bash(grpcurl --version:*)"
  "Bash(hadolint --version:*)"
  "Bash(haskell --version:*)"
  "Bash(hdiutil info:*)"
  "Bash(head:*)"
  "Bash(helix --version:*)"
  "Bash(helm --version:*)"
  "Bash(helm dependency list:*)"
  "Bash(helm env:*)"
  "Bash(helm get:*)"
  "Bash(helm history:*)"
  "Bash(helm list:*)"
  "Bash(helm ls:*)"
  "Bash(helm repo list:*)"
  "Bash(helm search:*)"
  "Bash(helm show:*)"
  "Bash(helm status:*)"
  "Bash(helm template:*)"
  "Bash(helm version:*)"
  "Bash(hexdump:*)"
  "Bash(host:*)"
  "Bash(hostname:*)"
  "Bash(htmlq --version:*)"
  "Bash(http --version:*)"
  "Bash(https --version:*)"
  "Bash(hx --version:*)"
  "Bash(hyperfine --version:*)"
  "Bash(hyperfine:*)"
  "Bash(id:*)"
  "Bash(iex --version:*)"
  "Bash(ifconfig:*)"
  "Bash(influx version:*)"
  "Bash(info:*)"
  "Bash(ioreg -l:*)"
  "Bash(ioreg:*)"
  "Bash(ip addr:*)"
  "Bash(ip link:*)"
  "Bash(ip route:*)"
  "Bash(isort --version:*)"
  "Bash(java --version:*)"
  "Bash(java -version:*)"
  "Bash(javac --version:*)"
  "Bash(javac -version:*)"
  "Bash(jenv version:*)"
  "Bash(jenv versions:*)"
  "Bash(jq --version:*)"
  "Bash(jq:*)"
  "Bash(jsonlint --version:*)"
  "Bash(julia --version:*)"
  "Bash(just --list:*)"
  "Bash(just --version:*)"
  "Bash(k9s version:*)"
  "Bash(keychain --version:*)"
  "Bash(kind get clusters:*)"
  "Bash(kind get nodes:*)"
  "Bash(kind version:*)"
  "Bash(kotlin -version:*)"
  "Bash(kotlinc -version:*)"
  "Bash(kubectl api-resources:*)"
  "Bash(kubectl api-versions:*)"
  "Bash(kubectl auth can-i:*)"
  "Bash(kubectl auth whoami:*)"
  "Bash(kubectl cluster-info:*)"
  "Bash(kubectl config current-context:*)"
  "Bash(kubectl config get-contexts:*)"
  "Bash(kubectl config view:*)"
  "Bash(kubectl describe:*)"
  "Bash(kubectl diff:*)"
  "Bash(kubectl events:*)"
  "Bash(kubectl explain:*)"
  "Bash(kubectl get:*)"
  "Bash(kubectl help:*)"
  "Bash(kubectl logs:*)"
  "Bash(kubectl top:*)"
  "Bash(kubectl version:*)"
  "Bash(launchctl list:*)"
  "Bash(launchctl print:*)"
  "Bash(ld --version:*)"
  "Bash(lein --version:*)"
  "Bash(lein deps :tree:*)"
  "Bash(less:*)"
  "Bash(lipo -info:*)"
  "Bash(litecli --version:*)"
  "Bash(lldb --version:*)"
  "Bash(llvm-config --version:*)"
  "Bash(locale:*)"
  "Bash(log show:*)"
  "Bash(ls:*)"
  "Bash(lsd --version:*)"
  "Bash(lsd:*)"
  "Bash(lsof:*)"
  "Bash(ltrace --version:*)"
  "Bash(lua -v:*)"
  "Bash(luarocks --version:*)"
  "Bash(luarocks list:*)"
  "Bash(make --version:*)"
  "Bash(mamba --version:*)"
  "Bash(mamba info:*)"
  "Bash(mamba list:*)"
  "Bash(man:*)"
  "Bash(markdownlint --version:*)"
  "Bash(md5:*)"
  "Bash(md5sum:*)"
  "Bash(mdfind:*)"
  "Bash(mdls:*)"
  "Bash(mdutil -s:*)"
  "Bash(meson --version:*)"
  "Bash(minikube ip:*)"
  "Bash(minikube profile list:*)"
  "Bash(minikube status:*)"
  "Bash(minikube version:*)"
  "Bash(mise current:*)"
  "Bash(mise list:*)"
  "Bash(mise plugins:*)"
  "Bash(mix --version:*)"
  "Bash(mix deps.tree:*)"
  "Bash(mongo --version:*)"
  "Bash(mongosh --version:*)"
  "Bash(more:*)"
  "Bash(mtr --version:*)"
  "Bash(mvn --version:*)"
  "Bash(mvn -v:*)"
  "Bash(mvn dependency:list:*)"
  "Bash(mvn dependency:resolve:*)"
  "Bash(mvn dependency:tree:*)"
  "Bash(mvn help:describe:*)"
  "Bash(mvn help:effective-pom:*)"
  "Bash(mvn help:effective-settings:*)"
  "Bash(mvn help:system:*)"
  "Bash(mycli --version:*)"
  "Bash(mypy --version:*)"
  "Bash(mysql --version:*)"
  "Bash(mysqldump --version:*)"
  "Bash(nano --version:*)"
  "Bash(navi --version:*)"
  "Bash(nc -z:*)"
  "Bash(netstat:*)"
  "Bash(networksetup -getinfo:*)"
  "Bash(networksetup -listallhardwareports:*)"
  "Bash(networksetup -listnetworkserviceorder:*)"
  "Bash(nim --version:*)"
  "Bash(nimble --version:*)"
  "Bash(nimble list:*)"
  "Bash(ninja --version:*)"
  "Bash(nl:*)"
  "Bash(nm --version:*)"
  "Bash(nmap --version:*)"
  "Bash(node --version:*)"
  "Bash(node -v:*)"
  "Bash(npm --version)"
  "Bash(npm -v:*)"
  "Bash(npm audit:*)"
  "Bash(npm bin:*)"
  "Bash(npm config get:*)"
  "Bash(npm config list:*)"
  "Bash(npm doctor:*)"
  "Bash(npm explain:*)"
  "Bash(npm fund:*)"
  "Bash(npm help:*)"
  "Bash(npm info:*)"
  "Bash(npm list:*)"
  "Bash(npm ls:*)"
  "Bash(npm outdated:*)"
  "Bash(npm pkg get:*)"
  "Bash(npm prefix:*)"
  "Bash(npm query:*)"
  "Bash(npm root:*)"
  "Bash(npm search:*)"
  "Bash(npm show:*)"
  "Bash(npm view:*)"
  "Bash(npm why:*)"
  "Bash(npx --version:*)"
  "Bash(npx -v:*)"
  "Bash(nslookup:*)"
  "Bash(nuget --version:*)"
  "Bash(nvim --version:*)"
  "Bash(nvm --version:*)"
  "Bash(nvm current:*)"
  "Bash(nvm list:*)"
  "Bash(objdump --version:*)"
  "Bash(ocaml --version:*)"
  "Bash(od:*)"
  "Bash(op --version:*)"
  "Bash(opam --version:*)"
  "Bash(opam list:*)"
  "Bash(openssl version:*)"
  "Bash(otool:*)"
  "Bash(oxlint --version:*)"
  "Bash(packer --version:*)"
  "Bash(pandoc --version:*)"
  "Bash(pass --version:*)"
  "Bash(paste:*)"
  "Bash(pdftotext:*)"
  "Bash(pdm --version:*)"
  "Bash(pdm config:*)"
  "Bash(pdm info:*)"
  "Bash(pdm list:*)"
  "Bash(pdm show:*)"
  "Bash(perl --version:*)"
  "Bash(perl -v:*)"
  "Bash(pg_config --version:*)"
  "Bash(pg_dump --version:*)"
  "Bash(pgcli --version:*)"
  "Bash(php --version:*)"
  "Bash(php -v:*)"
  "Bash(ping -c:*)"
  "Bash(pip --version:*)"
  "Bash(pip -V:*)"
  "Bash(pip check:*)"
  "Bash(pip config get:*)"
  "Bash(pip config list:*)"
  "Bash(pip debug:*)"
  "Bash(pip freeze:*)"
  "Bash(pip help:*)"
  "Bash(pip index versions:*)"
  "Bash(pip list:*)"
  "Bash(pip show:*)"
  "Bash(pip3 --version:*)"
  "Bash(pip3 freeze:*)"
  "Bash(pip3 list:*)"
  "Bash(pip3 show:*)"
  "Bash(pipx --version:*)"
  "Bash(pipx list:*)"
  "Bash(pmset -g:*)"
  "Bash(pnpm --version:*)"
  "Bash(pnpm -v:*)"
  "Bash(pnpm audit:*)"
  "Bash(pnpm bin:*)"
  "Bash(pnpm config list:*)"
  "Bash(pnpm env list:*)"
  "Bash(pnpm list:*)"
  "Bash(pnpm ls:*)"
  "Bash(pnpm outdated:*)"
  "Bash(pnpm root:*)"
  "Bash(pnpm why:*)"
  "Bash(poetry --version:*)"
  "Bash(poetry check:*)"
  "Bash(poetry config --list:*)"
  "Bash(poetry env info:*)"
  "Bash(poetry env list:*)"
  "Bash(poetry search:*)"
  "Bash(poetry show:*)"
  "Bash(poetry version:*)"
  "Bash(pre-commit --version:*)"
  "Bash(prettier --version:*)"
  "Bash(procs --version:*)"
  "Bash(procs:*)"
  "Bash(protoc --version:*)"
  "Bash(ps:*)"
  "Bash(psql --version:*)"
  "Bash(pulumi config:*)"
  "Bash(pulumi stack ls:*)"
  "Bash(pulumi version:*)"
  "Bash(pulumi whoami:*)"
  "Bash(pwd:*)"
  "Bash(pyenv --version:*)"
  "Bash(pyenv version:*)"
  "Bash(pyenv versions:*)"
  "Bash(pyenv which:*)"
  "Bash(pylint --version:*)"
  "Bash(python --version:*)"
  "Bash(python -V:*)"
  "Bash(python3 --version:*)"
  "Bash(python3 -V:*)"
  "Bash(qlmanage -p:*)"
  "Bash(qpdf:*)"
  "Bash(rails --version:*)"
  "Bash(rake --version:*)"
  "Bash(rake -T:*)"
  "Bash(ranlib --version:*)"
  "Bash(rbenv --version:*)"
  "Bash(rbenv version:*)"
  "Bash(rbenv versions:*)"
  "Bash(rbenv which:*)"
  "Bash(read:*)"
  "Bash(readlink:*)"
  "Bash(realpath:*)"
  "Bash(rebar3 --version:*)"
  "Bash(redis-cli --version:*)"
  "Bash(redis-server --version:*)"
  "Bash(rev:*)"
  "Bash(rg:*)"
  "Bash(route:*)"
  "Bash(rsync --version:*)"
  "Bash(ruby --version:*)"
  "Bash(ruby -v:*)"
  "Bash(ruff --version:*)"
  "Bash(ruff check:*)"
  "Bash(rustc --version:*)"
  "Bash(rustc -V:*)"
  "Bash(rustfmt --version:*)"
  "Bash(rustup --version:*)"
  "Bash(rustup check:*)"
  "Bash(rustup component list:*)"
  "Bash(rustup show:*)"
  "Bash(rustup target list:*)"
  "Bash(rustup toolchain list:*)"
  "Bash(rustup which:*)"
  "Bash(rvm --version:*)"
  "Bash(rvm info:*)"
  "Bash(rvm list:*)"
  "Bash(sbt --version:*)"
  "Bash(sbt about:*)"
  "Bash(sbt version:*)"
  "Bash(scala --version:*)"
  "Bash(scala -version:*)"
  "Bash(scc --version:*)"
  "Bash(scc:*)"
  "Bash(scp -V:*)"
  "Bash(screen -list:*)"
  "Bash(screen -v:*)"
  "Bash(scutil --dns:*)"
  "Bash(scutil --nc list:*)"
  "Bash(scutil --proxy:*)"
  "Bash(sdk current:*)"
  "Bash(sdk list:*)"
  "Bash(sdk version:*)"
  "Bash(security find-identity:*)"
  "Bash(security list-keychains:*)"
  "Bash(seq:*)"
  "Bash(shasum:*)"
  "Bash(shell-commands:*)"
  "Bash(shellcheck --version:*)"
  "Bash(shfmt --version:*)"
  "Bash(shfmt:*)"
  "Bash(size --version:*)"
  "Bash(softwareupdate --list:*)"
  "Bash(sops --version:*)"
  "Bash(sort:*)"
  "Bash(spctl --assess:*)"
  "Bash(spctl --status:*)"
  "Bash(sqlite3 --version:*)"
  "Bash(sqlite3 -version:*)"
  "Bash(ss:*)"
  "Bash(ssh -V:*)"
  "Bash(ssh-keygen -l:*)"
  "Bash(stack --version:*)"
  "Bash(starship --version:*)"
  "Bash(stat:*)"
  "Bash(strace --version:*)"
  "Bash(strings:*)"
  "Bash(strip --version:*)"
  "Bash(sw_vers:*)"
  "Bash(swift --version:*)"
  "Bash(swift package describe:*)"
  "Bash(swift package show-dependencies:*)"
  "Bash(swiftc --version:*)"
  "Bash(sysctl:*)"
  "Bash(system_profiler:*)"
  "Bash(tail:*)"
  "Bash(task --list:*)"
  "Bash(task --version:*)"
  "Bash(taskfile --version:*)"
  "Bash(terraform --version:*)"
  "Bash(terraform fmt -check:*)"
  "Bash(terraform graph:*)"
  "Bash(terraform help:*)"
  "Bash(terraform output:*)"
  "Bash(terraform plan:*)"
  "Bash(terraform providers:*)"
  "Bash(terraform show:*)"
  "Bash(terraform state list:*)"
  "Bash(terraform state show:*)"
  "Bash(terraform validate:*)"
  "Bash(terraform version:*)"
  "Bash(terraform workspace list:*)"
  "Bash(terraform workspace show:*)"
  "Bash(terragrunt --version:*)"
  "Bash(test:*)"
  "Bash(tldr:*)"
  "Bash(tmux -V:*)"
  "Bash(tmux list-sessions:*)"
  "Bash(tmux list-windows:*)"
  "Bash(tofu --version:*)"
  "Bash(tofu output:*)"
  "Bash(tofu providers:*)"
  "Bash(tofu state list:*)"
  "Bash(tofu version:*)"
  "Bash(tokei --version:*)"
  "Bash(tokei:*)"
  "Bash(top -l 1:*)"
  "Bash(tr:*)"
  "Bash(traceroute:*)"
  "Bash(tree:*)"
  "Bash(tsc --version:*)"
  "Bash(type:*)"
  "Bash(uname:*)"
  "Bash(uniq:*)"
  "Bash(uptime:*)"
  "Bash(uv --version:*)"
  "Bash(uv pip check:*)"
  "Bash(uv pip freeze:*)"
  "Bash(uv pip list:*)"
  "Bash(uv pip show:*)"
  "Bash(uv python list:*)"
  "Bash(uv tool list:*)"
  "Bash(uv version:*)"
  "Bash(vagrant --version:*)"
  "Bash(vagrant global-status:*)"
  "Bash(vagrant status:*)"
  "Bash(valgrind --version:*)"
  "Bash(vi --version:*)"
  "Bash(vim --version:*)"
  "Bash(virtualenv --version:*)"
  "Bash(vm_stat:*)"
  "Bash(volta --version:*)"
  "Bash(volta list:*)"
  "Bash(watchman --version:*)"
  "Bash(watchman watch-list:*)"
  "Bash(wc:*)"
  "Bash(wget --version:*)"
  "Bash(which:*)"
  "Bash(whoami:*)"
  "Bash(whois:*)"
  "Bash(xcode-select --print-path:*)"
  "Bash(xcode-select -p:*)"
  "Bash(xcodebuild -showsdks:*)"
  "Bash(xcodebuild -version:*)"
  "Bash(xcrun --find:*)"
  "Bash(xcrun --show-sdk-path:*)"
  "Bash(xcrun --version:*)"
  "Bash(xq --version:*)"
  "Bash(xxd:*)"
  "Bash(yamllint --version:*)"
  "Bash(yarn --version:*)"
  "Bash(yarn -v:*)"
  "Bash(yarn audit:*)"
  "Bash(yarn bin:*)"
  "Bash(yarn config get:*)"
  "Bash(yarn config list:*)"
  "Bash(yarn info:*)"
  "Bash(yarn list:*)"
  "Bash(yarn outdated:*)"
  "Bash(yarn why:*)"
  "Bash(yq --version:*)"
  "Bash(zellij --version:*)"
  "Bash(zig version:*)"
  "Bash(zoxide --version:*)"
  "Bash(zoxide query:*)"
  "Glob"
  "Grep"
  "Read"
  "Read(///**)"
  "WebFetch"
  "WebSearch"
  "mcp__ide__getDiagnostics"
)

# src/lib/settings.sh
# Claude Code settings.json manipulation helpers

# These get initialized by init_claude_paths()
CLAUDE_DIR=""
CLAUDE_SETTINGS=""
CLAUDE_HOOKS_DIR=""
HOOK_FILE_PREFIX=""

# Track files modified that are managed by chezmoi (used by shell_alias.sh too)
CHEZMOI_MODIFIED_FILES=()

# Check if any chezmoi files were modified
has_chezmoi_modifications() {
  [[ ${#CHEZMOI_MODIFIED_FILES[@]} -gt 0 ]]
}

# --- Initialization (must be called before using other functions) ---

init_claude_paths() {
  # CLAUDE_DIR_OVERRIDE is for testing only (not exposed as CLI flag)
  local custom_dir="${CLAUDE_DIR_OVERRIDE:-}"

  # Check if chezmoi manages ~/.claude
  if [[ -z "$custom_dir" ]] && is_claude_managed_by_chezmoi; then
    CLAUDE_DIR="$(chezmoi source-path)/dot_claude"
    HOOK_FILE_PREFIX="executable_"
    # Track that ~/.claude is managed by chezmoi
    CHEZMOI_MODIFIED_FILES+=("$HOME/.claude")
    info "Detected chezmoi managing ~/.claude"
    info "Installing to: $CLAUDE_DIR"
  else
    CLAUDE_DIR="${custom_dir:-$HOME/.claude}"
    HOOK_FILE_PREFIX=""
  fi

  CLAUDE_SETTINGS="$CLAUDE_DIR/settings.json"
  CLAUDE_HOOKS_DIR="$CLAUDE_DIR/hooks"
}

is_claude_managed_by_chezmoi() {
  # Check if chezmoi is installed
  if ! command -v chezmoi &>/dev/null; then
    return 1
  fi

  # Check if ~/.claude is managed by chezmoi
  chezmoi source-path ~/.claude &>/dev/null
}

get_hook_filename() {
  echo "${HOOK_FILE_PREFIX}auto-approve-allowed-commands.sh"
}

get_hook_filepath() {
  echo "$CLAUDE_HOOKS_DIR/$(get_hook_filename)"
}

# --- Public API (step-down: high-level functions first) ---

set_setting() {
  local jq_path="$1"  # e.g., '.env.SHELL'
  local value="$2"    # JSON value, e.g., '"string"' or '123' or 'true'
  local current new

  current=$(get_settings)
  new=$(echo "$current" | jq "$jq_path = $value")
  write_settings "$new"
}

get_setting() {
  local jq_path="$1"  # e.g., '.env.SHELL'
  get_settings | jq -r "$jq_path // empty"
}

array_contains() {
  local jq_path="$1"  # e.g., '.permissions.allow'
  local value="$2"    # JSON value to check for, e.g., '"Bash(ls:*)"'

  get_settings | jq -e "$jq_path | index($value) != null" &>/dev/null
}

array_add() {
  local jq_path="$1"  # e.g., '.permissions.allow'
  local value="$2"    # JSON value to add, e.g., '"Bash(ls:*)"'
  local current new

  if array_contains "$jq_path" "$value"; then
    return 0
  fi

  current=$(get_settings)
  # First ensure the path exists, then add the value
  new=$(echo "$current" | jq "
    if $jq_path == null then
      $jq_path = []
    else
      .
    end
    | $jq_path += [$value]
    | $jq_path = ($jq_path | unique)
  ")
  write_settings "$new"
}

merge_setting() {
  local jq_path="$1"  # e.g., '.hooks'
  local obj="$2"      # JSON object to merge, e.g., '{"PreToolUse": [...]}'
  local current new

  current=$(get_settings)
  new=$(echo "$current" | jq "$jq_path = (($jq_path // {}) * $obj)")
  write_settings "$new"
}

# --- Directory management ---

ensure_claude_dir() {
  if [[ ! -d "$CLAUDE_DIR" ]]; then
    mkdir -p "$CLAUDE_DIR"
    info "Created $CLAUDE_DIR"
  fi
}

ensure_hooks_dir() {
  ensure_claude_dir
  if [[ ! -d "$CLAUDE_HOOKS_DIR" ]]; then
    mkdir -p "$CLAUDE_HOOKS_DIR"
    info "Created $CLAUDE_HOOKS_DIR"
  fi
}

# --- Low-level settings I/O ---

get_settings() {
  if [[ -f "$CLAUDE_SETTINGS" ]]; then
    cat "$CLAUDE_SETTINGS"
  else
    echo '{}'
  fi
}

write_settings() {
  local json="$1"
  ensure_claude_dir
  echo "$json" | jq '.' > "$CLAUDE_SETTINGS"
}

# --- Hook configuration ---

configure_hook_in_settings() {
  if hook_already_configured; then
    return 0
  fi
  add_hook_to_settings
}

add_hook_to_settings() {
  # Settings always reference the non-prefixed filename at $HOME/.claude
  # (prefix is only for dotfiles managers like chezmoi)
  # shellcheck disable=SC2016
  local new_hook='{"type": "command", "command": "$HOME/.claude/hooks/auto-approve-allowed-commands.sh"}'

  local current new
  current=$(get_settings)

  # Check if a Bash matcher already exists in PreToolUse
  if echo "$current" | jq -e '.hooks.PreToolUse[]? | select(.matcher == "Bash")' &>/dev/null; then
    # Append our hook to the existing Bash matcher's hooks array
    new=$(echo "$current" | jq --argjson hook "$new_hook" '
      .hooks.PreToolUse = [
        .hooks.PreToolUse[] |
        if .matcher == "Bash" then
          .hooks += [$hook]
        else
          .
        end
      ]
    ')
  else
    # No Bash matcher exists, create a new entry
    local hook_entry
    hook_entry=$(jq -n --argjson hook "$new_hook" '{
      "matcher": "Bash",
      "hooks": [$hook]
    }')
    new=$(echo "$current" | jq --argjson entry "$hook_entry" '
      .hooks.PreToolUse = ((.hooks.PreToolUse // []) + [$entry])
    ')
  fi

  write_settings "$new"
}

hook_already_configured() {
  # Check if PreToolUse has a Bash matcher with auto-approve-allowed-commands.sh command
  get_settings | jq -e '
    .hooks.PreToolUse[]?
    | select(.matcher == "Bash")
    | .hooks[]?
    | select(.command | endswith("auto-approve-allowed-commands.sh"))
  ' &>/dev/null
}

# src/lib/shell_alias.sh
# Shell alias configuration for Claude Code
# Adds aliases to shell config files to set SHELL env var when running claude

# Marker comment to identify our alias block
ALIAS_MARKER="# Added by better-claude-code for shell alias"

# Note: CHEZMOI_MODIFIED_FILES is defined in settings.sh
# TARGET_FILE is set by get_config_target() to avoid subshell issues
TARGET_FILE=""

# --- Public API ---

# Configure shell alias in all detected shell configs
configure_shell_alias() {
  local shell_path="$1"
  local configured=false

  # Bash
  if [[ -f "$HOME/.bashrc" ]]; then
    configure_alias "bash" "$shell_path" "$HOME/.bashrc"
    configured=true
  fi

  # Zsh
  if [[ -f "$HOME/.zshrc" ]]; then
    configure_alias "zsh" "$shell_path" "$HOME/.zshrc"
    configured=true
  fi

  # Fish
  local fish_config="$HOME/.config/fish/config.fish"
  if [[ -f "$fish_config" ]]; then
    configure_alias "fish" "$shell_path" "$fish_config"
    configured=true
  fi

  if [[ "$configured" == false ]]; then
    warn "No shell config files found to configure"
    return 1
  fi
}

# --- Per-shell configuration ---

# Configure alias for a specific shell
# Args: shell_type (bash|zsh|fish), shell_path, config_file
configure_alias() {
  local shell_type="$1"
  local shell_path="$2"
  local config_file="$3"

  # Sets TARGET_FILE global (avoids subshell so CHEZMOI_MODIFIED_FILES persists)
  get_config_target "$config_file"
  local target_file="$TARGET_FILE"

  if alias_already_configured "$target_file"; then
    info "${shell_type^} alias already configured"
    return 0
  fi

  local alias_block
  alias_block=$(generate_alias "$shell_type" "$shell_path")

  append_to_config "$target_file" "$alias_block"
  success "Added claude alias to $(basename "$target_file")"
}

# --- Alias generators ---

generate_alias() {
  local shell_type="$1"
  local shell_path="$2"

  if [[ "$shell_type" == "fish" ]]; then
    cat <<EOF

$ALIAS_MARKER
function claude
  SHELL="$shell_path" command claude \$argv
end
EOF
  else
    # bash and zsh use identical syntax
    cat <<EOF

$ALIAS_MARKER
claude() {
  SHELL="$shell_path" command claude "\$@"
}
EOF
  fi
}

# --- Helpers ---

# Get the target file to write to (handles chezmoi)
# Sets TARGET_FILE global instead of echoing (to avoid subshell issues with array tracking)
get_config_target() {
  local config_file="$1"
  local relative_path="${config_file#$HOME/}"

  # Check if this specific file is managed by chezmoi
  if is_file_managed_by_chezmoi "$relative_path"; then
    local chezmoi_source
    chezmoi_source=$(chezmoi source-path "$config_file" 2>/dev/null)
    if [[ -n "$chezmoi_source" ]]; then
      # Track that we modified a chezmoi-managed file
      CHEZMOI_MODIFIED_FILES+=("$config_file")
      TARGET_FILE="$chezmoi_source"
      return
    fi
  fi

  TARGET_FILE="$config_file"
}

is_file_managed_by_chezmoi() {
  local relative_path="$1"

  if ! command -v chezmoi &>/dev/null; then
    return 1
  fi

  chezmoi source-path "$HOME/$relative_path" &>/dev/null
}

alias_already_configured() {
  local file="$1"
  grep -q "$ALIAS_MARKER" "$file" 2>/dev/null
}

append_to_config() {
  local file="$1"
  local content="$2"

  echo "$content" >> "$file"
}

# :command.command_functions

# :command.parse_requirements
parse_requirements() {
  local key

  # :command.fixed_flags_filter
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      --version | -v)
        version_command
        exit
        ;;

      --help | -h)
        long_usage=yes
        install.sh_usage
        exit
        ;;

      *)
        break
        ;;

    esac
  done

  # :command.command_filter
  action="root"

  # :command.parse_requirements_while
  while [[ $# -gt 0 ]]; do
    key="$1"
    case "$key" in
      # :flag.case
      --shell | -s)

        # :flag.case_arg
        if [[ -n ${2+x} ]]; then
          args['--shell']="$2"
          shift
          shift
        else
          printf "%s\n" "--shell requires an argument: --shell, -s SHELL_PATH" >&2
          exit 1
        fi
        ;;

      # :flag.case
      --yes | -y)

        # :flag.case_no_arg
        args['--yes']=1
        shift
        ;;

      -?*)
        printf "invalid option: %s\n" "$key" >&2
        exit 1
        ;;

      *)
        # :command.parse_requirements_case
        # :command.parse_requirements_case_simple
        printf "invalid argument: %s\n" "$key" >&2
        exit 1

        ;;

    esac
  done

}

# :command.initialize
initialize() {
  declare -g version="0.1.0"
  set -e

}

# :command.run
run() {
  # :command.globals
  declare -g long_usage=''
  declare -g -A args=()
  declare -g -A deps=()
  declare -g -a env_var_names=()
  declare -g -a input=()

  normalize_input "$@"
  parse_requirements "${input[@]}"

  case "$action" in
    "root") root_command ;;
  esac
}

if [[ "${BASH_SOURCE[0]}" == "${0}" ]]; then
  # :command.start
  command_line_args=("$@")
  initialize
  run "${command_line_args[@]}"
fi

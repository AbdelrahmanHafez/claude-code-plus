# This file contains a function that generates the auto-approve-allowed-commands.sh hook script
# The script is generated with the correct CLAUDE_DIR path baked in

generate_hook_script() {
  local claude_dir="$1"

  cat << HOOK_EOF
#!/usr/bin/env bash
# auto-approve-allowed-commands.sh - Hook to auto-approve compound commands where ALL components match allowed Bash permissions.
# Claude Code's prefix matching doesn't handle pipes - this hook fixes that.
#
# Dynamically reads allowed commands from:
#   1. $claude_dir/settings.json (global)
#   2. .claude/settings.json (project shared)
#   3. .claude/settings.local.json (project local)
#
# Dependencies: shfmt, jq
#
# Generated by better-claude-code installer

set -euo pipefail

# Configured claude directory
CLAUDE_DIR="$claude_dir"

# --- Main entry point ---

main() {
  parse_args "\$@"
  check_dependencies || exit 0

  local command
  command=\$(read_command_from_stdin) || exit 0
  [[ -z "\$command" ]] && exit 0

  check_command_allowed "\$command"
}

# --- High-level logic ---

check_command_allowed() {
  local command="\$1"
  local -a allowed_prefixes
  local -a extracted_commands

  mapfile -t allowed_prefixes < <(get_allowed_prefixes)
  debug "Loaded \${#allowed_prefixes[@]} allowed prefixes"

  if [[ \${#allowed_prefixes[@]} -eq 0 ]]; then
    debug "No Bash permissions found, exiting"
    exit 0
  fi

  mapfile -d '' extracted_commands < <(parse_shell_commands "\$command" 2>&1) || {
    debug "Command parsing failed, falling through"
    exit 0
  }

  debug "Extracted \${#extracted_commands[@]} commands:"
  for cmd in "\${extracted_commands[@]}"; do
    debug "  - \$cmd"
  done

  if [[ \${#extracted_commands[@]} -eq 0 ]] || [[ -z "\${extracted_commands[0]}" ]]; then
    debug "No commands found in input, allowing"
    output_allow
    exit 0
  fi

  if all_commands_allowed extracted_commands allowed_prefixes; then
    debug "Decision: ALLOW (all commands passed)"
    output_allow
  else
    debug "Decision: BLOCK (falling through to normal permission check)"
  fi

  exit 0
}

all_commands_allowed() {
  local -n commands_ref=\$1
  local -n prefixes_ref=\$2

  for full_command in "\${commands_ref[@]}"; do
    [[ -z "\$full_command" ]] && continue
    if ! is_command_allowed "\$full_command" prefixes_ref; then
      return 1
    fi
  done

  return 0
}

is_command_allowed() {
  local full_command="\$1"
  local -n prefixes=\$2

  for allowed in "\${prefixes[@]}"; do
    if [[ "\$full_command" == "\$allowed" ]] || \\
       [[ "\$full_command" == "\$allowed "* ]] || \\
       [[ "\$full_command" == "\$allowed/"* ]]; then
      debug "ALLOWED: '\$full_command' (matches '\$allowed')"
      return 0
    fi
  done

  debug "BLOCKED: '\$full_command' (no matching prefix)"
  return 1
}

# --- Input/Output ---

read_command_from_stdin() {
  local input command

  input=\$(cat)
  debug "Input JSON: \$input"

  command=\$(echo "\$input" | jq -r '.tool_input.command // empty')
  debug "Extracted command: \$command"

  echo "\$command"
}

output_allow() {
  echo '{"hookSpecificOutput":{"hookEventName":"PreToolUse","permissionDecision":"allow"}}'
}

# --- Settings and prefixes ---

get_allowed_prefixes() {
  local git_root
  git_root=\$(find_git_root)

  {
    extract_prefixes_from_file "\$CLAUDE_DIR/settings.json"

    if [[ -n "\$git_root" ]]; then
      extract_prefixes_from_file "\$git_root/.claude/settings.json"
      extract_prefixes_from_file "\$git_root/.claude/settings.local.json"
    else
      extract_prefixes_from_file ".claude/settings.json"
      extract_prefixes_from_file ".claude/settings.local.json"
    fi
  } | sort -u
}

extract_prefixes_from_file() {
  local file="\$1"

  if [[ ! -f "\$file" ]]; then
    debug "Settings file not found: \$file"
    return 0
  fi

  debug "Reading prefixes from: \$file"
  jq -r '.permissions.allow[]? // empty' "\$file" 2>/dev/null \\
    | grep -E '^Bash\(' \\
    | sed -E 's/^Bash\(([^:]+)(:\*)?.*/\1/'
}

find_git_root() {
  git rev-parse --show-toplevel 2>/dev/null
}

# --- Shell command parser ---

parse_shell_commands() {
  local cmd="\$1"
  local raw_commands

  debug "Input command: \$cmd"
  raw_commands=\$(extract_commands_raw "\$cmd") || return 1

  while IFS= read -r line; do
    [[ -z "\$line" ]] && continue

    local inner
    inner=\$(get_shell_c_inner "\$line")

    if [[ -n "\$inner" ]]; then
      debug "Found shell -c, recursing into: \$inner"
      parse_shell_commands "\$inner"
    else
      printf '%s\0' "\$line"
    fi
  done <<< "\$raw_commands"
}

extract_commands_raw() {
  local cmd="\$1"
  local ast

  debug "Parsing: \$cmd"
  cmd=\$(normalize_for_shfmt "\$cmd")
  debug "Normalized: \$cmd"

  if ! ast=\$(echo "\$cmd" | shfmt -ln bash -tojson 2>&1); then
    debug "Parse error: \$ast"
    return 1
  fi

  debug "AST parsed successfully"
  echo "\$ast" | jq -r "\$JQ_FILTER" 2>/dev/null
}

normalize_for_shfmt() {
  local cmd="\$1"
  echo "\$cmd" | perl -pe 's/\[\[\s*\\\\?!\s+(.+?)\s+=~\s*/! [[ \$1 =~ /g'
}

get_shell_c_inner() {
  local cmd="\$1"

  if [[ "\$cmd" =~ ^(bash|sh)[[:space:]]+-c[[:space:]]*[\'\"](.*)[\'\"]\$ ]]; then
    echo "\${BASH_REMATCH[2]}"
  elif [[ "\$cmd" =~ ^(bash|sh)[[:space:]]+-c[\'\"](.*)[\'\"]\$ ]]; then
    echo "\${BASH_REMATCH[2]}"
  fi
}

# --- Dependencies and setup ---

check_dependencies() {
  if ! command -v shfmt &>/dev/null; then
    debug "shfmt not found, falling through"
    return 1
  fi

  if ! command -v jq &>/dev/null; then
    debug "jq not found, falling through"
    return 1
  fi

  return 0
}

parse_args() {
  DEBUG=false
  [[ "\${1:-}" == "--debug" ]] && DEBUG=true
}

debug() {
  if \$DEBUG; then
    echo "[DEBUG] \$*" >&2
  fi
}

# --- jq filter for AST parsing ---

read -r -d '' JQ_FILTER << 'JQEOF' || true
def get_part_value:
  if (type == "object" | not) then ""
  elif .Type == "Lit" then .Value // ""
  elif .Type == "DblQuoted" then
    "\"" + ([.Parts[]? | get_part_value] | join("")) + "\""
  elif .Type == "SglQuoted" then
    "'" + (.Value // "") + "'"
  elif .Type == "ParamExp" then
    "\$" + (.Param.Value // "")
  elif .Type == "CmdSubst" then
    "\$(..)"
  else
    ""
  end;

def get_arg_value:
  [.Parts[]? | get_part_value] | join("");

def get_command_string:
  if .Type == "CallExpr" and .Args then
    [.Args[] | get_arg_value] | map(select(length > 0)) | join(" ")
  else
    empty
  end;

def extract_commands:
  if type == "object" then
    if .Type == "CallExpr" then
      get_command_string,
      (.Args[]?.Parts[]? | select(.Type == "CmdSubst") | .Stmts[]? | extract_commands)
    elif .Type == "BinaryCmd" then
      (.X | extract_commands),
      (.Y | extract_commands)
    elif .Type == "Subshell" or .Type == "Block" then
      (.Stmts[]? | extract_commands)
    elif .Type == "CmdSubst" then
      (.Stmts[]? | extract_commands)
    elif .Type == "IfClause" then
      (.Cond[]? | extract_commands),
      (.Then[]? | extract_commands),
      (.Else | extract_commands)
    elif .Type == "WhileClause" or .Type == "UntilClause" then
      (.Cond[]? | extract_commands),
      (.Do[]? | extract_commands)
    elif .Type == "ForClause" then
      (.Do[]? | extract_commands)
    elif .Type == "CaseClause" then
      (.Items[]?.Stmts[]? | extract_commands)
    elif .Cmd then
      (.Cmd | extract_commands)
    elif .Stmts then
      (.Stmts[] | extract_commands)
    else
      (.[] | extract_commands)
    end
  elif type == "array" then
    (.[] | extract_commands)
  else
    empty
  end;

extract_commands | select(length > 0)
JQEOF

# --- Run main ---

main "\$@"
HOOK_EOF
}
